
<body onload=start()><font face=helvetica>
<script src=js/g.js></script>
<script src=js/m4.js></script>

<center>
<b><big>
<b><big>
<b><big>
Topics in computer graphics
</big></b>
</big></b>
<p>
<i>Ken Perlin</i>
</big></b>
</center>
<center><table width=90%><tr><td><hr color=white size=20>

<hr><big><b>
Images and colors
</b></big><p>

<table width=100%><tr><td valign=top>

<b><i>
How does a computer store an image?
</i></b><p>
An image looks like a two dimensional array
of pixels, nCols wide by nRows high,
but it is generally stored in the computer
as a one dimensional array of pixel values.
The index into this array of a given pixel is:
<blockquote>
row * nCols + col   
</blockquote>
In the illustration to the right, you can
move your mouse over the image to select
a single pixel.
You can also select a pixel by moving
your mouse over the linear array below the image.
Each element of this array corresponds to exactly
one pixel of the image.

</td><td width=20></td><td valign=top>
<canvas id=imageScanning width=400 height=200 tabindex="1"></canvas>
</td></tr></table>

<p>
<b><i>
How humans see colors
</i></b><p>
<table width=100%><tr><td valign=top>
The human retina actually contains three different kinds of color receptor cells, each of which has a range of sensitivity to different parts of the visible light spectrum (which ranges from about 400 nanometers to 700 nm in wavelength).
The illustration on the right shows an approximation to the color sensitivity of each of these types of receptors.
<p>
We approximate this in a computer by three numbers at each pixel: one for red, green and blue, respectively.  But this is an imperfect approximation.
In fact there are many combinations of [r,g,b] that the human eye cannot properly perceive, because our three types of color receptors overlap across the spectrum,
as you can see by moving your mouse across the illustration to the right.
<p>
Complicating things even further, the "red", "green", and "blue" components of your computer screen each actually contain a mix of light frequencies.

</td><td width=20></td><td valign=top>
<canvas id=humanColors width=400 height=250 tabindex="1"></canvas>
</td></tr></table>

<hr><big><b>
Representing shapes with polygons
</b></big><p>

<p>

<table width=100%><tr><td valign=top>

<b><i>
Cube
</i></b><p>

A unit cube is the cube that goes from -1.0 to +1.0
in all three dimensions.
Its eight vertices are [-1,-1,-1], [-1,1,+1] ... [+1,+1,+1].
<p>

It is fairly easy to represent a unit cube with triangles.
<p>
Move your mouse over the illustration on the right
to see one way to make a cube out of twelve triangles.

</td><td width=20></td><td valign=top>
<canvas id=cube width=400 height=250 tabindex="1"></canvas>
</td></tr></table>
<p>

<table width=100%><tr><td valign=top>

<b><i>
Cylinder
</i></b><p>

A cylinder can be approximated by triangles by
constructing an approximation to a round tube and
two approximately circular end caps.
<p>

Both the tube and the end caps will not truly
be round, but rather will be built around an N-sided polygon
which only approximates a circle.
As N gets larger, the approximation will become better,
while the cost of storing and computing the shape will go up.
<p>

You can see the appearance of different approximations
by moving your mouse around the illustration to the right.


</td><td width=20></td><td valign=top>
<canvas id=cylinder width=400 height=250 tabindex="1"></canvas>
</td></tr></table>
<p>

<table width=100%><tr><td valign=top>

<b><i>
Sphere
</i></b><p>
There are many ways to approximate
a sphere with triangular meshes.
One way is by building a longitude/latitude grid.

<p>

Another way to approximate a sphere
with polygons is to subdivide each
of the six faces of a unit cube into
a mesh, and then "inflate" the cube.
<p>
This inflation is done by scaling
the length of each
vertex [x,y,z] of the cube so
that
(x<sup>2</sup> + y<sup>2</sup> + z<sup>2</sup>)
is equal for all vertices.
<p>
After this is done, all vertices
will be the same distance from the origin,
and the cube will deform into a sphere.
<p>
This method has the advantage that
it is very simple to implement,
while producing relatively similar sized
polygons everywhere on the sphere.
<p>

Finally, if you want the result to consist only of
triangles, you can split each of the squares into two
triangles along one of its long diagonals.
</td><td width=20></td><td valign=top>
<canvas id=cubeMeshSphere width=400 height=300 tabindex="1"></canvas>

</td></tr></table>

<script>
  var m = new M4();

  var cubeVert = [[-1,-1,-1],[ 1,-1,-1],[-1, 1,-1],[ 1, 1,-1],
                  [-1,-1, 1],[ 1,-1, 1],[-1, 1, 1],[ 1, 1, 1]];
  var cubeEdge = [[0,1],[2,3],[4,5],[6,7],
                  [0,2],[1,3],[4,6],[5,7],
	          [0,4],[1,5],[2,6],[3,7]];

  var eps = 0.5;
  var inflation = 0.0, rotation = 0.0;

  function inflate(p) {
     var r = sqrt((p[0]*p[0] + p[1]*p[1] + p[2]*p[2]) / 3);
     return [lerp(inflation, p[0], p[0] / r),
             lerp(inflation, p[1], p[1] / r),
             lerp(inflation, p[2], p[2] / r)];
  }

   function drawSquareFace(t, isDiag) {
     var u = isDiag ? t/4 : 0;

     var z = m._m()[10];
     var c = max(0.2, .5 + .5 * z / (width()/8));
     lineWidth(c);

     var A  = m.transform([-1-u,-1-u, 1+t]);

     var B0 = m.transform([ 1-u,-1-u, 1+t]);
     var C0 = m.transform([-1-u, 1-u, 1+t]);

     var B1 = m.transform([ 1+u,-1+u, 1+t]);
     var C1 = m.transform([-1+u, 1+u, 1+t]);

     var D  = m.transform([ 1+u, 1+u, 1+t]);

     line(A [0], A [1], B0[0], B0[1]);
     line(A [0], A [1], C0[0], C0[1]);

     line(D [0], D [1], B1[0], B1[1]);
     line(D [0], D [1], C1[0], C1[1]);

     if (isDiag) {
        line(B0[0], B0[1], C0[0], C0[1]);
	if (t > 0)
           line(B1[0], B1[1], C1[0], C1[1]);
     }
  }

   function drawMeshFace(c) {
     color(c);
     for (var u = -1 ; u <= 1 ; u += eps)
     for (var v = -1 ; v <= 1 ; v += eps) {
         var A = m.transform(inflate([u,v,1]));
         var B = m.transform(inflate([u+eps,v,1]));
         var C = m.transform(inflate([u,v+eps,1]));
	      if (u < 1) line(A[0], A[1], B[0], B[1]);
	      if (v < 1) line(A[0], A[1], C[0], C[1]);
     }
   }

  imageScanning.setup = function() {
     textHeight(width()/20);
     this.row = 0;
     this.col = 0;
  }

  imageScanning.animate = function() {
     var w = width(), h = height();
     var x = this.mouseX, y = this.mouseY;

     var X = w/4, Y = 1, W = w/2;

     if (x >= X && x < X + W && y >= Y && y < Y + W*4/6) {
        this.col = floor(6 * (x - X) / W);
        this.row = floor(6 * (y - Y) / W);
     }

     else if (y >= h/2) {
        var n = max(0, min(23, 26 * x / w - 1));
        this.col = floor(n % 6);
        this.row = floor(n / 6);
     }

     var s = W / 6;
     for (var i = 0 ; i < 6 ; i++)
     for (var j = 0 ; j < 4 ; j++) {
        if (i == this.col && j == this.row)
	   fillRect(X + i * s, 1 + Y + j * s, s, s);
	drawRect(X + i * s, 1 + Y + j * s, s, s);
     }

     for (var n = 0 ; n < 24 ; n++) {
        if (n == this.row * 6 + this.col)
           fillRect((n + 1) * w / 26, h-w/10, w/26, w/26);
        drawRect((n + 1) * w / 26, h-w/10, w/26, w/26);
     }

     text("col:", w/40, w/20);
     text("row:", w/40, w/20 + w/10);
     text(this.col, w/40 + w/7, w/20);
     text(this.row, w/40 + w/7, w/20 + w/10);
  }

  function drawCurve(pts) {
     var w = width(), h = height();
     for (var n = 0 ; n < pts.length - 2 ; n += 2) {
        var x0 = (pts[n    ] - .04) / .81;
        var y0 = pts[n + 1] * 4/5;
        var x1 = (pts[n + 2] - .04) / .81;
        var y1 = pts[n + 3] * 4/5;
	line(w * x0, h * (4/5-y0), w * x1, h * (4/5-y1));
     }
  }

  function evalCurve(pts, x) {
     for (var n = 0 ; n < pts.length - 2 ; n += 2) {
        var x0 = (pts[n    ] - .04) / .81;
        var y0 = pts[n + 1] * 4/5;
        var x1 = (pts[n + 2] - .04) / .81;
        var y1 = pts[n + 3] * 4/5;
	if (x0 < x && x1 > x)
	   return y0 + (y1 - y0) * (x - x0) / (x1 - x0);
     }
     return 0;
  }

  var blueCurve = [
     .05,0, .09,.14, .18,.6, .192,.62, .208,.62, .22,.6,
     .3,.185, .33,.1, .37,.025, .4,0,
  ];

  var greenCurve = [
     .1,0, .2,.05, .25,.1, .3,.2, .4,.8, .43,.9, .45,.92, .47,.9,
     .54,.67, .62,.3, .67,.17, .70,.1, .77,.01, .82,0,
  ];

  var redCurve = [
     .05,0, .09,.08, .11,.08, .14,.05, .17,.04,
     .2,.045, .25,.08, .3,.12, .32,.15, .34,.2,
     .40,.54, .42,.62, .45,.70, .5,.8, .52,.82, .55,.8,
     .57,.75, .70,.23, .74,.12, .78,.05, .81,.02, .85,0,
  ];

  humanColors.animate = function() {
     var w = width(), h = height(), x = this.mouseX, y1 = h*4/5;
     textHeight(w/48);
     color('black');
     drawRect(2,2,w-4,y1-3);
     var ty = y1 + w/32;
     text("400", 0, ty);
     text("500", w/3 - w/20/3, ty);
     text("600", w*2/3 - w/20*2/3, ty);
     text("700", w - w/20, ty);


     textHeight(w/30);

     color('red');
     drawCurve(redCurve);

     var yr = evalCurve(redCurve, x / w);
     fillOval(x - 3, h * (4/5 - yr) - 3, 6, 6);

     text("R:", w/60, w/20);
     fillRect(w/16, w/20*0.3, h * yr / 3, w/30);


     color('#00e000');
     drawCurve(greenCurve);

     var yg = evalCurve(greenCurve, x / w);
     fillOval(x - 3, h * (4/5 - yg) - 3, 6, 6);

     text("G:", w/60, w/20 * 2);
     fillRect(w/16, w/20*1.3, h * yg / 3, w/30);


     color('blue');
     drawCurve(blueCurve);

     var yb = evalCurve(blueCurve, x / w);
     fillOval(x - 3, h * (4/5 - yb) - 3, 6, 6);

     text("B:", w/60, w/20 * 3);
     fillRect(w/16, w/20*2.3, h * yb / 3, w/30);


     color('black');
     line(x, 0, x, y1);
  }

  cube.animate = function() {
     var w = width(), h = height(), x = this.mouseX, y = this.mouseY;

     var dx = x/(w/2) - 1;
     var dy = y/(w/2) - 1;
     var rotation = -dx;
     var t = max(0, min(.5, 4 * (dy + .5)));

     var isDiag = x > w/40 && x < w-w/40;
     if (! isDiag)
        t = 0;

     m.push();
        standardView(0.5, 0.55, rotation, 0.3, 0.5);

	m.push(); m.rotateX( PI  ); drawSquareFace(t, isDiag); m.pop();
	m.push(); m.rotateX(-PI/2); drawSquareFace(t, isDiag); m.pop();
	m.push(); m.rotateY( PI/2); drawSquareFace(t, isDiag); m.pop();
	m.push();                        drawSquareFace(t, isDiag); m.pop();
	m.push(); m.rotateX( PI/2); drawSquareFace(t, isDiag); m.pop();
	m.push(); m.rotateY(-PI/2); drawSquareFace(t, isDiag); m.pop();
     m.pop();
  }

  cylinder.animate = function() {
     var w = width(), h = height(), x = this.mouseX, y = this.mouseY;
     var dx = x/(w/2) - 1;
     var dy = y/(h/2) - 1;
     var rotation = -dx;
     var N = floor(4 + max(0, 23.5 * (1 + dy)));

     textHeight(w/25);
     text("N = " + N, w/25, h/2);

     m.push();
        standardView(0.5, 0.55, rotation, 0.3, 0.5);

	var SP = m.transform([0,0,-1]);
	var NP = m.transform([0,0, 1]);

        for (var n = 0 ; n < N ; n++) {
	   var c0 = cos(2 * PI * n / N);
	   var s0 = sin(2 * PI * n / N);
	   var c1 = cos(2 * PI * (n + 1) / N);
	   var s1 = sin(2 * PI * (n + 1) / N);

	   var A0 = m.transform([c0,s0,-1]);
	   var A1 = m.transform([c1,s1,-1]);
	   var B0 = m.transform([c0,s0, 1]);
	   var B1 = m.transform([c1,s1, 1]);

           lineWidth(0.3);
	   line(SP[0], SP[1], A0[0], A0[1]);
           lineWidth(0.6);
	   line(A0[0], A0[1], B0[0], B0[1]);
           lineWidth(1.0);
	   line(A0[0], A0[1], A1[0], A1[1]);
	   line(NP[0], NP[1], B0[0], B0[1]);
	   line(B0[0], B0[1], B1[0], B1[1]);
	   line(A0[0], A0[1], A1[0], A1[1]);
	   line(B0[0], B0[1], B1[0], B1[1]);
	}
     m.pop();
  }

  cubeMeshSphere.animate = function() {
     var dx = this.mouseX/(width()/2) - 1;
     var dy = this.mouseY/(height()/2) - 1;
     rotation = -dx;
     inflation = sCurve(max(0, min(1, 4 * dy)));

     m.push();
        standardView(0.5, 0.5, rotation, 0.3, 0.7);

        lineWidth(0.5);
	m.push(); m.rotateX( PI  ); drawMeshFace('#0000ff'); m.pop();
	m.push(); m.rotateX(-PI/2); drawMeshFace('#00e000'); m.pop();
	m.push(); m.rotateY( PI/2); drawMeshFace('#ff0000'); m.pop();

        lineWidth(3.0);
	color('black');
        var A = m.transform(inflate([-1,0,0]));
        var B = m.transform(inflate([-1,1,0]));
	arrow(width()/2, height()/2, A[0], A[1]);
	arrow(width()/2, height()/2, B[0], B[1]);

        lineWidth(1.0);
	m.push();                        drawMeshFace('#0000ff'); m.pop();
	m.push(); m.rotateX( PI/2); drawMeshFace('#00e000'); m.pop();
	m.push(); m.rotateY(-PI/2); drawMeshFace('#ff0000'); m.pop();

     m.pop();
  }
</script>

<hr>
<table width=100%><tr>
<td valign=top>
<big><b>
Homogeneous coordinates
</b></big>
<p>

  Represent a point in <i>homogeneous coordinates</i>, by [x,y,z,w],
  which is used to represent the physical location [x/w,y/w,z/w].
<p>
  So a coordinate transformation could consist of <b>X</b>, <b>Y</b> and <b>Z</b> direction vectors
  and a position vector <b>T</b> as the translated origin.  These can be written in a 4x4 matrix
  as shown below:

  <center>
  <table border=1>
  <tr>
  <th width=20>&nbsp;<p>X<br>&nbsp;<br>0
  <th width=20>&nbsp;<p>Y<br>&nbsp;<br>0
  <th width=20>&nbsp;<p>Z<br>&nbsp;<br>0
  <th width=20>&nbsp;<p>T<br>&nbsp;<br>1
  </table>
  </center>
<p>
<td width=50>
<td>
<canvas id=coordinates width=250 height=250 tabindex="1"></canvas>
</table>

<hr>
<table width=100%><tr>
<td valign=top>
<big><b>
Forming a ray
</b></big>
<p>
 <b><i>Computing V</i></b>
 <p>
A simple place to put the camera eye point is
along the positive z axis,
so we can look at objects at the origin.
If we place this eye point a distance of fl
away (where "fl" is short for "focal length"),
then we get:
<blockquote>
<code><b>V</b> = [0.0, 0.0, fl, 1.0]</code>
</blockquote>
<p>
The homogeneous coordinate of <b>V</b> is 1.0, which
indicates that <b>V</b> is a point,
not a direction.
 <p>
 <b><i>Computing W</i></b>
 <p>
We want the ray direction <b>W</b>
to "scan" the image, as <i>u</i>
and <i>v</i> each vary from 0.0 to 1.0.
For any given value of [u,v],
we can define a ray direction:
<blockquote>
<code><b>W</b> = normalize([u-0.5, 0.5-v, -fl, 0.0])</code>
</blockquote>
</td>
<td width=50></td>
<td>
<canvas id=createRay width=300 height=300 tabindex="1"></canvas>
</td>

</tr></table>

<hr>
<big><b>
Ray tracing to a sphere
</b></big>
<p>
<table width=100%><tr>
<td valign=top>

 <b><i>Equation of a sphere, centered at <b>c</b>, with radius r:</i></b>
 <blockquote>
 (x-c<sub>x</sub>)<sup>2</sup> +
 (y-c<sub>y</sub>)<sup>2</sup> +
 (z-c<sub>z</sub>)<sup>2</sup> - r<sup>2</sup> = 0
 </blockquote>
 <p>
 <b><i>Substitute components of ray equation into sphere equation:</i></b>
<p>
Substituting:

 <blockquote>
 x &rarr; V<sub>x</sub> + t W<sub>x</sub><br>
 y &rarr; V<sub>y</sub> + t W<sub>y</sub><br>
 z &rarr; V<sub>z</sub> + t W<sub>z</sub><br>
 </blockquote>
produces:
<blockquote>
 (V<sub>x</sub> + t W<sub>x</sub> - c<sub>x</sub>)<sup>2</sup> +
 (V<sub>y</sub> + t W<sub>y</sub> - c<sub>y</sub>)<sup>2</sup> +
 (V<sub>z</sub> + t W<sub>z</sub> - c<sub>z</sub>)<sup>2</sup> - r<sup>2</sup> = 0
</blockquote>
which equals:
<blockquote>
(t W<sub>x</sub> + (V<sub>x</sub> - c<sub>x</sub>))<sup>2</sup> +
(t W<sub>y</sub> + (V<sub>y</sub> - c<sub>y</sub>))<sup>2</sup> +
(t W<sub>z</sub> + (V<sub>z</sub> - c<sub>z</sub>))<sup>2</sup> - r<sup>2</sup> = 0
</blockquote>
</td>
<td width=50></td>
<td>
<canvas id=raySphere width=368 height=368 tabindex="1"></canvas>
</td>

</tr></table>

Regrouping terms, we get:
<blockquote>
<b>t<sup>2</sup></b>
<font color=red>(
W<sub>x</sub><sup>2</sup> +
W<sub>y</sub><sup>2</sup> +
W<sub>z</sub><sup>2</sup> )</font> +
<p>
<b>t</b>
<font color=#00a000>( 2 (
W<sub>x</sub> (V<sub>x</sub> - c<sub>x</sub>) +
W<sub>y</sub> (V<sub>y</sub> - c<sub>y</sub>) +
W<sub>z</sub> (V<sub>z</sub> - c<sub>z</sub>) ) )</font> +
<p>

<font color=blue>
(V<sub>x</sub> - c<sub>x</sub>)<sup>2</sup> +
(V<sub>y</sub> - c<sub>y</sub>)<sup>2</sup> +
(V<sub>z</sub> - c<sub>z</sub>)<sup>2</sup> - r<sup>2</sup></font>

= 0
</blockquote>
which equals:
<blockquote>
<font color=red>
<b>W</b>&bull;<b>W</b> </font><b>t<sup>2</sup></b>
+
<font color=#00a000>
2<b>W</b>&bull;(<b>V</b>-<b>c</b>) </font><b>t</b>
+
<font color=blue>
(<b>V</b>-<b>c</b>)&bull;(<b>V</b>-<b>c</b>) - r<sup>2</sup>
</font>
= 0

</blockquote>
 <p>
 <b><i>So we need to solve the quadratic equation for</i></b>:
 <blockquote>
 <font color=red>
A = <b>W</b>&bull;<b>W</b>
 </font>
 <p>
 <font color=#00a000>
B = 2<b>W</b>&bull;(<b>V</b>-<b>c</b>)
 </font>
 <p>
 <font color=blue>
C = (<b>V</b>-<b>c</b>)&bull;(<b>V</b>-<b>c</b>) - r<sup>2</sup>
 </font>
 </blockquote>
 where the quadratic equation is:
 <blockquote>
 t = <big>(-</big>B &plusmn;
 <span style="white-space: nowrap">
 &radic;<span style="text-decoration:overline;">B<sup>2</sup>-4AC</span></span><big>)</big> / 2A
 </blockquote>
 Since w is normalized, the value of <b>W</b>&bull;<b>W</b> is always 1.0, so the quadratic equation in this case simplifies to:
 <blockquote>
 t = <big>(-</big>B &plusmn;
 <span style="white-space: nowrap">
 &radic;<span style="text-decoration:overline;">B<sup>2</sup>-4C</span></span><big></big> / 2
 </blockquote>
 <p>
 <b><i>Interpreting the results:</i></b>
 <p>
 If there are no real roots, then the ray has missed the sphere.
 <p>
 Otherwise, the smaller of the two roots is where the ray enters the sphere,
 and the larger of the two roots is where the sphere exists the sphere.
 <p>
 <p>
 <b><i>Using the root value to find the surface point:</i></b>
 <p>
 Once we have found the smaller root t, we can substitute it
 back into the ray equation to get the surface point S:
 <blockquote>
 <b>S</b> = <b>V</b> + t <b>W</b>
 </blockquote>
 <p>

<hr>
<big><b>
Simple lighting model:
</b></big>
<p>

 <b><i>Lights at infinity (like the Sun)</i></b>
 <p>
 We are going to assume for now that light sources are
 infinitely far away, or at least far enough away that they can
 be considered infinitely far for practical purposes,
 like the Sun, which is 93 million miles from Earth.
 <p>
 This means that the direction vector <b>L</b> to the light source
 will have the same value for all points in the scene:
 <blockquote>
<b>L</b> = [
L<sub>x</sub>,
L<sub>y</sub>,
L<sub>z</sub>,
0 ]
 </blockquote>
 <p>
<table width=100%><tr>
<td valign=top>
 <b><i>Lambert shading</i></b>
 <p>
We are going to assume for now that the surface is a perfect
scattering diffuser, like moondust.
In this case, incoming light from any direction scatters equally
out to all directions.  Such a surface is called <i>Lambertian</i>.
<p>
The brightness of a Lambertian surface depends only upon
the cosine between its surface normal and the direction toward the light source.
<p>
<b><i>Computing the surface normal</i></b>
<p>
For a sphere, it is easy to compute the surface normal.
It is simply the unit length (ie: normalized) vector from
the center of the sphere toward the surface point:
<blockquote>
<b>n</b> = normalize(<b>s</b> - <b>c</b>)
</blockquote>
Once we know the surface normal vector <b>n</b>, then we can calculate Lambertian reflectance by:
<blockquote>
[r,g,b] * max( 0, <b>n</b> &bull; <b>L</b> )
</blockquote>

<p>
Where [r,g,b] is the color of the surface.

There is usually some ambient light bouncing around in the scene in all directions. The above equation can be modified to account for an approximation to that ambient light:

<blockquote>
[r,g,b] * (A + (1.0 - A) * max( 0, <b>n</b> &bull; <b>L</b> ))
</blockquote>
Ambient reflectance is typically set to a low value, such as 0.1.

</td>
<td width=20></td>
<td>
<canvas id=lambert width=400 height=400 tabindex="1"></canvas>
</td>
</tr></table>
<hr>
<table width=100%><tr>
<td valign=top>
<big><b>
Reflections:
</b></big>
<p>
 <b><i>Physical model: clear plastic with embedded dye particles</i></b>
 <p>
 There are many types of materials.  One common type is
 plastic with embedded dye particles.
 Photons that penetrate the plastic will bounce off multiple particles.
 If the photon is not absorbed, it emerges in a random direction,
 to create Lambertian reflectance.
 <p>
 Those photons that simply bounce off the surface will create mirror-like reflections,
 if the surface of the plastic is smooth.
 This portion of the surface reflectance
 can be handled by computing a reflection ray, and then
 ray tracing again into the scene starting from the point of emergence.
 <p>
 <b><i>Computing the reflection vector</i></b>
 <p>
 Given an incoming ray direction <b>W</b>
 and a surface normal direction <b>N</b>, we can calculate the
 emergent reflection direction by:
 <blockquote>
 R = 2 (<b>-W</b> &bull; <b>N</b>) <b>N</b> + <b>W</b>
 </blockquote>

 <p>
 <b><i>Shooting the ray (no recursion in shader programs)</i></b>
 <p>
 We can therefore form a new ray, starting a small distance &epsilon; outside the sphere surface, as:
 <blockquote>
 <b>V'</b> = <b>S</b> + &epsilon; <b>R</b>
 <p>
 <b>W'</b> = <b>R</b>
 </blockquote>
You should use a small positive value for &epsilon;, such as 0.001.

</td>
<td width=20></td>
<td>
<canvas id=reflection width=400 height=400 tabindex="1"></canvas>
</td>
</tr></table>

 <p>
 <b><i>Adding in the reflection</i></b>
 <p>
The reflected ray can simply be multiplied by some [r,g,b] color and added to the final color of the surface point.
<p>
Note that you cannot have the ray tracer call itself recursively in the shader, because WebGL shader programs which run on the GPU do not permit recursive function calls.  But you can call the ray tracer for the primary ray, and then call it again to compute a reflection ray.
 <p>

<hr>
<table width=100%><tr>
<td valign=top>
<big><b>
Shadows:
</b></big>
<p>
 <b><i>Shooting the shadow ray</i></b>
 <p>
Shadows are a bit like reflections, but simpler.  To compute whether a surface point is in shadow, simply shoot a ray toward the light source.
If any object is hit by the ray, then the surface point is in shadow.
The shadow ray is formed as follows:
<blockquote>
<b>V'</b> = <b>S</b> + &epsilon; <b>L</b>
<p>
<b>W'</b> = <b>L</b>
</blockquote>
 <p>
 <b><i>Using the result</i></b>
<p>
The effect of a surface point being in shadow is that the point will have only ambient reflectance [Ar,Ag,Ab].
 <p>
<td width=50>
</td><td valign=top width=20></td><td>
<canvas id=shadow width=300 height=300 tabindex="1"></canvas>
</td></tr></table><p>


<script>
   var m = new M4();

   var cubeVert = [[-1,-1,-1],[ 1,-1,-1],[-1, 1,-1],[ 1, 1,-1],
                   [-1,-1, 1],[ 1,-1, 1],[-1, 1, 1],[ 1, 1, 1]];
   var cubeEdge = [[0,1],[2,3],[4,5],[6,7],
                   [0,2],[1,3],[4,6],[5,7],
                   [0,4],[1,5],[2,6],[3,7]];

   function drawCube() {
      for (var i = 0 ; i < cubeEdge.length ; i++) {
         var A = m.transform(cubeVert[cubeEdge[i][0]]);
         var B = m.transform(cubeVert[cubeEdge[i][1]]);
         line(A[0], A[1], B[0], B[1]);
      }
   }

   function mLine(a, b) {
      var A = m.transform(a);
      var B = m.transform(b);
      line(A[0], A[1], B[0], B[1]);
   }

   function mArrow(a, b) {
      var A = m.transform(a);
      var B = m.transform(b);
      arrow(A[0], A[1], B[0], B[1]);
   }

   function mText(str, p) {
      var P = m.transform(p);
      text(str, P[0], P[1]);
   }

   function vecAdd(a, b) {
      return [a[0] + b[0], a[1] + b[1], a[2] + b[2]];
   }

   function vecScale(a, s) {
      return [s * a[0], s * a[1], s * a[2]];
   }

   function vecLerp(t, a, b) {
      return [lerp(t,a[0],b[0]), lerp(t,a[1],b[1]), lerp(t,a[2],b[2])];
   }

   createRay.u = 0.5;
   createRay.v = 0.5;
   createRay.rotation = .5;

   createRay.animate = function() {
      color('red');

      var w = width();
      var h = height();

      var x0 = w/4, x1 = x0 + w/2;
      var y0 = h/4, y1 = y0 + h/2;

      var V = [0,0,2];

      var u = (this.mouseX-x0)/(x1-x0);
      var v = (y1-this.mouseY)/(y1-y0);
      if (u >= 0 && v >= 0 && u < 1 && v < 1) {
         this.u = u;
         this.v = v;
      }

      var x = lerp(  this.u, x0, x1);
      var y = lerp(1-this.v, y0, y1);

      var c00 = [-1,-.75,0];
      var c01 = [-1, .75,0];
      var c10 = [ 1,-.75,0];
      var c11 = [ 1, .75,0];

      m.push();

         textHeight(w/48);
         var W = [(2*this.u-1),(2*this.v-1)*.75,-2];
	 var aim = vecAdd(V, W);
         m.normalize(W);

         m.translate(w/2, h/2, 0);
         m.perspective(0,0,-2*w);
         m.rotateX(.2);
         m.rotateY(this.rotation);
         m.scale(100,-100,100);

	 mLine(vecLerp(this.u,c00,c10), vecLerp(this.u,c01,c11));
	 mLine(vecLerp(this.v,c00,c01), vecLerp(this.v,c10,c11));

         color('black');

	 mLine(c00,c01);
	 mLine(c10,c11);
	 mLine(c00,c10);
	 mLine(c01,c11);
	 mArrow(V, aim);

         textHeight(w/32);

	 var p = m.transform(V);
         text("V", p[0], p[1] - w/32);

	 var q = m.transform(vecAdd(V, vecScale(W, 0.8)));
         text("W", q[0], q[1] - w/32);

      m.pop();
   }

   coordinates.setup = function() {
      this.rotateX = 0;
      this.rotateY = 0;
   }

   coordinates.animate = function() {
      var w = width();
      var h = height();

      this.rotateX = this.mouseY / (h/2);
      this.rotateY = 1 - this.mouseX / (w/2);

      var a = [0,.3,2];
      var d = [-.4,.6,-2];
      var b = vecLerp(.35, a, d);
      var c = vecLerp(.65, a, d);

      m.push();
         m.translate(w/2-w/30, h/2+w/30, 0);
         m.perspective(0,0,-2*w);
         m.rotateX(this.rotateX);
         m.rotateY(this.rotateY);
         m.scale(w/4,-w/4,w/4);

	 color('#000000');
         lineWidth(2);
         textHeight(w/16);
	 mArrow([0,0,0],[1.5,0,0]);
	 mArrow([0,0,0],[0,1.5,0]);
	 mArrow([0,0,0],[0,0,1.5]);

	 var mb = m.transform([0,0,0]);
	 color('#ffffff');
	 fillOval(mb[0]-w/10,mb[1]-w/10,w/5,w/5);
	 color('#000000');

	 mText("T", [-.1,-.1,.01]);
	 mText("X", [1.7-.05,-.05,0]);
	 mText("Y", [0-.05,1.7-.05,0]);
	 mText("Z", [0-.05,0-.05,1.7]);
      m.pop();
   }

   raySphere.setup = function() {
      this.rotation = 0;
   }

   raySphere.animate = function() {
      var w = width();
      var h = height();

      this.rotation = 1 - this.mouseX / (w/2);

      var a = [0,.3,2];
      var d = [-.4,.6,-2];
      var b = vecLerp(.35, a, d);
      var c = vecLerp(.65, a, d);

      m.push();
         m.translate(w/2, h/2, 0);
         m.perspective(0,0,-2*w);
         m.rotateX(.2);
         m.rotateY(this.rotation);
         m.scale(100,-100,100);

         lineWidth(3);
         color('blue');
	 mArrow(c, d);

	 var R = w/4;
	 color('#fff2f2');
	 fillOval(w/2-R,h/2-R,2*R,2*R);
	 color('black');
	 drawOval(w/2-R,h/2-R,2*R,2*R);

         color('blue');
	 lineWidth(2);
	 mLine(a, b);
	 lineWidth(1);

         color('#ff8080');
	 mLine(b, c);

         color('#8080ff');
	 mArrow(c, d);

	 color('#909090');
	 mArrow([0,0,0],[1.5,0,0]);
	 mArrow([0,0,0],[0,1.5,0]);
	 mArrow([0,0,0],[0,0,1.5]);
	 mText("X", [1.7-.05,-.05,0]);
	 mText("Y", [0-.05,1.7-.05,0]);
	 mText("Z", [0-.05,0-.05,1.7]);

	 var mb = m.transform(b);
	 fillOval(mb[0]-2,mb[1]-2,4,4);

	 var mc = m.transform(c);
	 fillOval(mc[0]-2,mc[1]-2,4,4);
      m.pop();
   }

   lambert.setup = function() {
      this.x = width() / 2;
      this.y = height() / 2;
      this.rotation = 0;
   }

   lambert.animate = function() {
      var w = width();
      var h = height();

      var R = w * .45;

      var x = this.mouseX - w/2;
      var y = this.mouseY - h/2;
      rr = x * x + y * y;
      if (rr < R * R) {
         this.x = x + w/2;
         this.y = y + h/2;
	 if (rr > .25 * R * R) {
            var r = sqrt(rr);
            this.x = (this.x - w/2) * .5 * R / r + w/2;
            this.y = (this.y - h/2) * .5 * R / r + h/2;
	 }
      }

      var grd = _g.createRadialGradient(this.x, this.y, 0, w/2, h/2, R);
      grd.addColorStop(0.0, '#ffffff');
      grd.addColorStop(0.3, '#f4f4f4');
      grd.addColorStop(0.5, '#e0e0e0');
      grd.addColorStop(0.9, '#b0b0b0');
      grd.addColorStop(1.0, '#909090');
      _g.fillStyle = grd;
      _g.fill();

      color('black');
      drawOval(w/2-R,h/2-R,2*R,2*R,64);
   }

   reflection.animate = function() {
      var w = width();
      var h = height();

      textHeight(w/32);

      var t = w/6 + (1.5 * this.mouseX / w) * w/6;
      var u = sqrt((w*.45)*(w*.45) - t*t);
      var y2 = h*.9;
      var y1 = y2 - u;
      var y0 = y1 - u;

      lineWidth(1);
      color('#000000');
      arrow(w/2, y2, w/2, y1);
      arrow(w/2, y1, w/2, y0);
      text("2(-W\u25cfN)N", w/2-30, y0-10);

      color('red');
      arrow(w/2-t, y1, w/2-5, y2-5);
      text("W", lerp(.5,w/2-t,w/2) - 21, lerp(.5,y1,y2) + 8);
      text("W", lerp(.5,w/2,w/2+t) + 2, lerp(.5,y0,y1) - 2);

      arrow(w/2, y0, w/2+t-3, y1-3);

      color('blue');
      arrow(w/2+3, y2-3, w/2+t, y1);
      text("R", lerp(.5,w/2,w/2+t) + 7, lerp(.5,y2,y1) + 7);

      color('black');
      lineWidth(2.5);
      arrow(w*.1, y2, w*.1, y2-w*.45);
      textHeight(w/16);
      text("N", w*.1 - 10, y2-w*.45 - 10);

      lineWidth(6);
      color('#b0b0b0');
      line(0, y2, w, y2);
   }

</script>

<hr>
<b><big>
Ray tracing to general second order surfaces
</big></b><p>

<table width=100% valign=top><tr><td>

<i><b>First a special case: ray tracing to an unit radius cylindrical tube</b></i><p>

The implicit function for a unit diameter
infinitely long cylindrical tube along the z axis is:
<blockquote>
x<sup>2</sup> + y<sup>2</sup> - 1 &le; 0
</blockquote>

We can solve the ray equation manually, like we did for the sphere, as follows:
<p>
<ul>
<li>Substituting in <b>V</b>+t<b>W</b> for (x,y,z):
<blockquote>
(V<sub>x</sub> + t W<sub>x</sub>)<sup>2</sup> + (V<sub>y</sub> + t W<sub>y</sub>)<sup>2</sup> - 1 &le; 0
</blockquote>
<li>Expanding out:
<blockquote>
(W<sub>x</sub><sup>2</sup> + W<sub>y</sub><sup>2</sup>) t<sup>2</sup> + (2 V<sub>x</sub> W<sub>x</sub> + 2 V<sub>y</sub> W<sub>y</sub>) t + (V<sub>x</sub><sup>2</sup> + V<sub>y</sub><sup>2</sup> - 1) &le; 0

</blockquote>
<li>Which just equals:
<blockquote>
(<b>W</b>&bull;<b>W</b>) t<sup>2</sup> + 2(<b>V</b>&bull;<b>W</b>) t + (<b>V</b>&bull;<b>V</b> - 1) &le; 0
</blockquote>

<li>So to solve the quadratic equation in t:

<blockquote>
A = <b>W</b>&bull;<b>W</b>
<br>
B = 2 (<b>V</b>&bull;<b>W</b>)
<br>
C = <b>V</b>&bull;<b>V</b> - 1
</blockquote>
</ul>
<p>

</td><td valign=top width=20></td><td>
<canvas id=ray_cylinder width=400 height=400 tabindex="1"></canvas>
</td></tr></table><p>
<p>

<table width=100% valign=top><tr><td>

But this would not give us the ability to
transform the cylinder, nor would it generalize
to other quadratic shapes, including cones, paraboloids and hyperboloids.
<p>
So instead, let's work on the general case of being
able to transform <i>any</i> implicit quadratic function
by 4&#215;4 matrix,
and then ray trace to it.
<p>

<b><i>The general second order implicit surface:</i></b><p>

Any quadratic implicit surface can be expressed as follows:
<blockquote>
ax<sup>2</sup> + by<sup>2</sup> + cz<sup>2</sup> + dyz + ezx + fxy + gx + hy + iz + j &le; 0
</blockquote>
The ten coefficients of this equation can be stored as a vector:
<blockquote>
[a, b, c, d, e, f, g, h, i, j]
</blockquote>

The unit sphere, the infinite unit cylinder and the infinite unit
cone, respectively, can all be expressed in such a form:
<blockquote>
<table>

<tr>
<td>
Sphere:
</td>
<td width=20></td>
<td>
x<sup>2</sup> + y<sup>2</sup> + z<sup>2</sup> - 1 &le; 0
</td>
<td width=20></td>
<td>
[1, 1, 1, 0, 0, 0, 0, 0, 0, -1]
</td>
</tr>

<tr>
<td>
Cylinder:
</td>
<td width=20></td>
<td>
x<sup>2</sup> + y<sup>2</sup> - 1 &le; 0
</td>
<td width=20></td>
<td>
[1, 1, 0, 0, 0, 0, 0, 0, 0, -1]
</td>
</tr>

<tr>
<td>
Cone:
</td>
<td width=20></td>
<td>
x<sup>2</sup> + y<sup>2</sup> - z<sup>2</sup> &le; 0
</td>
<td width=20></td>
<td>
[1, 1, -1, 0, 0, 0, 0, 0, 0, 0]
</td>
</tr>
</tr>

</table>
</blockquote>

<b><i>Raytracing to a general second order implicit surface:</i></b><p>

<p>
Ray tracing to the general form
just requires substituting the ray
into this equation to get a quadratic
equation in t, exactly as we did
above in the case of the cylinder:
<p>

<ul>

<li>Substituting in <b>V</b>+t<b>W</b> for (x,y,z):

<blockquote>
a(V<sub>x</sub>+tW<sub>x</sub>)<sup>2</sup> + b(V<sub>y</sub>+tW<sub>y</sub>)<sup>2</sup> + c(V<sub>z</sub>+tW<sub>z</sub>)<sup>2</sup> +
d(V<sub>y</sub>+tW<sub>y</sub>)(V<sub>z</sub>+tW<sub>z</sub>) + e(V<sub>z</sub>+tW<sub>z</sub>)(V<sub>x</sub>+tW<sub>x</sub>) + f(V<sub>x</sub>+tW<sub>x</sub>)(V<sub>y</sub>+tW<sub>y</sub>) +
g(V<sub>x</sub>+tW<sub>x</sub>) + h(V<sub>y</sub>+tW<sub>y</sub>) + i(V<sub>z</sub>+tW<sub>z</sub>) + j &le; 0
</blockquote>

<li>Expanding out:

<blockquote>

a(V<sub>x</sub>+tW<sub>x</sub>)(V<sub>x</sub>+tW<sub>x</sub>) + b(V<sub>y</sub>+tW<sub>y</sub>)(V<sub>y</sub>+tW<sub>y</sub>) + c(V<sub>z</sub>+tW<sub>z</sub>)(V<sub>z</sub>+tW<sub>z</sub>) + 
d(V<sub>y</sub>+tW<sub>y</sub>)(V<sub>z</sub>+tW<sub>z</sub>) + e(V<sub>z</sub>+tW<sub>z</sub>)(V<sub>x</sub>+tW<sub>x</sub>) + f(V<sub>x</sub>+tW<sub>x</sub>)(V<sub>y</sub>+tW<sub>y</sub>) + 
g(V<sub>x</sub>+tW<sub>x</sub>) + h(V<sub>y</sub>+tW<sub>y</sub>) + i(V<sub>z</sub>+tW<sub>z</sub>) + j &le; 0

</blockquote>

<li>Rearranging terms:

<blockquote>

<font color=red>
(aW<sub>x</sub><sup>2</sup> + bW<sub>y</sub><sup>2</sup> + cW<sub>z</sub><sup>2</sup> + dW<sub>y</sub>W<sub>z</sub> + eW<sub>z</sub>W<sub>x</sub> + fW<sub>x</sub>W<sub>y</sub>) </font> t<sup>2</sup> +
<font color=#00a000>
(2aV<sub>x</sub>W<sub>x</sub> + 2bV<sub>y</sub>W<sub>y</sub> + 2cV<sub>z</sub>W<sub>z</sub> + d(V<sub>y</sub>W<sub>z</sub>+V<sub>z</sub>W<sub>y</sub>) + e(V<sub>z</sub>W<sub>x</sub>+V<sub>x</sub>W<sub>z</sub>) + f(V<sub>x</sub>W<sub>y</sub>+V<sub>y</sub>W<sub>x</sub>) + gW<sub>x</sub> + hW<sub>y</sub> + iW<sub>z</sub>) </font> t +
<font color=blue>
(aV<sub>x</sub><sup>2</sup> + bV<sub>y</sub><sup>2</sup> + cV<sub>z</sub><sup>2</sup> + dV<sub>y</sub>V<sub>z</sub> + eV<sub>z</sub>V<sub>x</sub> + fV<sub>x</sub>V<sub>y</sub> + gV<sub>x</sub> + hV<sub>y</sub> + iV<sub>z</sub> + j) </font> &le; 0




</blockquote>

<li>So to solve the quadratic equation in t:

<blockquote>
<table>
<tr><td valign=top width=50> A &nbsp; = </td><td>
<font color=red>
aW<sub>x</sub><sup>2</sup> + bW<sub>y</sub><sup>2</sup> + cW<sub>z</sub><sup>2</sup> + dW<sub>y</sub>W<sub>z</sub> + eW<sub>z</sub>W<sub>x</sub> + fW<sub>x</sub>W<sub>y</sub>
</font>
</td></tr>
<tr><td>&nbsp;</td></tr>

<tr><td valign=top>B &nbsp; = </td><td>
<font color=#00a000>
2(aV<sub>x</sub>W<sub>x</sub> + bV<sub>y</sub>W<sub>y</sub> + cV<sub>z</sub>W<sub>z</sub>) + d(V<sub>y</sub>W<sub>z</sub>+V<sub>z</sub>W<sub>y</sub>) + e(V<sub>z</sub>W<sub>x</sub>+V<sub>x</sub>W<sub>z</sub>) + f(V<sub>x</sub>W<sub>y</sub>+V<sub>y</sub>W<sub>x</sub>) + gW<sub>x</sub> + hW<sub>y</sub> + iW<sub>z</sub>
</font>
</td></tr>
<tr><td>&nbsp;</td></tr>

<tr><td valign=top>C &nbsp; = </td><td>
<font color=blue>
aV<sub>x</sub><sup>2</sup> + bV<sub>y</sub><sup>2</sup> + cV<sub>z</sub><sup>2</sup> + dV<sub>y</sub>V<sub>z</sub> + eV<sub>z</sub>V<sub>x</sub> + fV<sub>x</sub>V<sub>y</sub> + gV<sub>x</sub> + hV<sub>y</sub> + iV<sub>z</sub> + j
</font>
</td></tr>
</table>

</blockquote>

</ul>
<p>


</td></tr></table><p>

<hr>
<table width=100% valign=top><tr><td>
<b><big>
Applying a linear transform to a second order surface
</big></b><p>

Let us first review the
simpler case of linear surfaces:
Half space <i><b>P</b></i> = (a, b, c, d)
contains point <b>p</b> = (x,y,z),
if and only if ax + by + cz + d &le; 0.
This can also be expressed as the product:
<p>
<blockquote>
<table>
<tr>

<td>
a b c d
<td>
&nbsp; &#149; &nbsp; 
<td bgcolor=#ffffff>
x<br>y<br>z<br>1
<td>
&nbsp;
&le;
&nbsp;
0
</table>
</blockquote>

<p>
or, in other words, <b><i>L</i> p<sup>T</sup></b> &le; 0.
To find the plane
that contains transformed points <b>M</b>&#149;<b>p<sup>T</sup></b>,
you need to 
replace <b><i>L</i></b> with <b><i>L</i></b>&#149;<b>M<sup>-1</sup></b>.
<p>

Similarly,
we can express quadratic equation
<blockquote>
ax<sup>2</sup> +
by<sup>2</sup> +
cz<sup>2</sup> +
dyz +
ezx +
fxy +
gx +
hy +
iz +
j &le; 0
</blockquote>
as the following double product:
<p>
<blockquote>
<table>
<tr>
<td>
x y z 1
<td>
&nbsp; &#149; &nbsp; 
<td bgcolor=#ffffff>
<table>
<tr><td align=center width=20>a<td align=center width=20>f
    <td align=center width=20>e<td align=center width=20>g
<tr><td align=center width=20>0<td align=center width=20>b
    <td align=center width=20>d<td align=center width=20>h
<tr><td align=center width=20>0<td align=center width=20>0
    <td align=center width=20>c<td align=center width=20>i
<tr><td align=center width=20>0<td align=center width=20>0
    <td align=center width=20>0<td align=center width=20>j
</table>
<td>
&nbsp; &#149; &nbsp; 
<td bgcolor=#ffffff>
x<br>y<br>z<br>1
<td>
&nbsp;
&le;
&nbsp;
0
</table>
</blockquote>
<p>

or in other words,
<b>p Q p<sup>T</sup></b> = 0,
where <b>Q</b>
denotes
the 10 quadratic coefficients
arranged into the above 4&#215;4 matrix.
<p>

This means that if you want
to find the three-variable quadratic equation
that contains transformed points <b>M</b>&#149;<b>p<sup>T</sup></b>,
you need to replace <b>Q</b>
by
&nbsp; <b>(M<sup>-1</sup>)<sup>T</sup> Q M<sup>-1</sup></b> &nbsp;
because that will give you:
<p>
<blockquote>
<b>
(M p<sup>T</sup>)<sup>T</sup>
&nbsp;
&nbsp;
<b>(M<sup>-1</sup>)<sup>T</sup> Q M<sup>-1</sup></b>
&nbsp;
&nbsp;
(M p<sup>T</sup>)
&nbsp; &nbsp; =
<p>
p<sup>T</sup> M<sup>T</sup>
&nbsp;
&nbsp;
<b>(M<sup>-1</sup>)<sup>T</sup> Q M<sup>-1</sup></b>
&nbsp;
&nbsp;
M p<sup>T</sup>
&nbsp; &nbsp; =
<p>
p Q p<sup>T</sup>
</b>
</blockquote>
<p>

when you
create the product of
<blockquote>
<b>(M<sup>-1</sup>)<sup>T</sup> P M<sup>-1</sup></b>
</blockquote>
you can end up with non-zero values in all sixteen slots of your 4&#215;4
matrix.  This is because in addition to
x*y, x*z, x*1, y*z, y*1, z*1 terms, you also
end up with
y*x, z*y, 1*z, z*y, 1*z, 1*z terms, as follows:
<blockquote>
<pre>
x*x x*y x*z x*1
<font color=magenta>y*x</font> y*y y*z y*1
<font color=magenta>z*x z*y</font> z*z z*1
<font color=magenta>1*x 1*y 1*z</font> 1*1
</pre>
</blockquote>

Since multiplication of numbers is commutative,
you can just add the six numbers in the lower left
(shown in <font color=magenta>magenta</font> above) into their mirror locations
on the upper right, as follows:

<blockquote>
<TABLE><TR>
<TD>
<table>
<tr><td align=center width=20>A<td align=center width=20>E
    <td align=center width=20>I<td align=center width=20>M
<tr><td align=center width=20>B<td align=center width=20>F
    <td align=center width=20>J<td align=center width=20>N
<tr><td align=center width=20>C<td align=center width=20>G
    <td align=center width=20>K<td align=center width=20>O
<tr><td align=center width=20>D<td align=center width=20>H
    <td align=center width=20>L<td align=center width=20>P
</table>
</TD>
<TH width=50><big>&nbsp; &nbsp; &rarr;</big>
</TH>
<TD>
<table>
<tr><td align=center width=40>A<td align=center width=40>E+B
    <td align=center width=40>I+C<td align=center width=40>M+D
<tr><td align=center width=40>0<td align=center width=40>F
    <td align=center width=40>J+G<td align=center width=40>N+H
<tr><td align=center width=40>0<td align=center width=40>0
    <td align=center width=40>K<td align=center width=40>O+L
<tr><td align=center width=40>0<td align=center width=40>0
    <td align=center width=40>0<td align=center width=40>P
</table>
</TD>
</TR></TABLE>
</blockquote>

This will leave you with just the ten unique
coefficients of the quadratic in three variables,
in the upper right of your transformed matrix.
</font>
<p>

<b><i>Computing the surface normal:</i></b><p>

Once you have computed your transformed values
for [a,b,c,d,e,f,g,h,i,j], you can use
high school differential calculus to
compute its vector valued derivative:

<blockquote>
f(x,y,z) = 
ax<sup>2</sup> + by<sup>2</sup> + cz<sup>2</sup> + dyz + ezx + fxy + gx + hy + iz + j
<p>
<b>f'</b>(x,y,z) = <big>[</big>&nbsp;
2ax + ez + fy + g &nbsp;,&nbsp;
2by + dz + fx + h &nbsp;,&nbsp;
2cz + dy + ex + i
&nbsp;<big>]</big>
</blockquote>

Just normalize this derivative to get the normal at the surface point:
<blockquote>
<b>N</b> = normalize(<b>f'</b>(x,y,z))
</blockquote>


</td></tr></table><p>

<hr>
<table width=100% valign=top><tr>
<td valign=top>
<b><big>
Light sources not at infinity
</big></b><p>

Light sources do not need to be at infinity.
A local light source can add interesting
<a href=http://en.wikipedia.org/wiki/Chiaroscuro target=1>
chiarioscuro</a> effects to your scene.
<p>
Unlike light sources at infinity,
a local light source at some position (x,y,z)
in your scene will more brightly illuminate surfaces
that are near to it, and less brightly illuminate
surface that are farther from it.
<p>
If a local light source were an infinitely small point,
then intensity drop-off from that point would be
1/r<sup>2</sup>, where r is the distance of the
surface from (x,y,z).
In reality, light sources, such as desk lamps, tend to have
some non-zero extent, and so their intensity drops off with
distance more slowly than 1/r<sup>2</sup>.
<p>

A simple computational trick to model this
slower dropoff is to define a power <i>p</i>,
where 1.0 &le; <i>p</i> &le; 2.0,
and define the dropoff function as 1/r<sup><i>p</i></sup>.
<p>

Another visual trick you might use with local light sources
is to give a very high ambient component to the
surface material of one of your objects (eg: a sphere),
and then place a local light source inside this object.
The object will then appear to be
a light source that illuminates the other objects
in your scene.

</td><td valign=top width=20></td><td>
<canvas id=local_lights width=400 height=400 tabindex="1"></canvas>
</td></tr></table><p>

<hr>
<table width=100% valign=top><tr><td>
<b><big>
Fog and atmosphere
</big></b><p>

Fog and atmosphere
is very easy to implement and can
make your ray traced scenes look a lot cooler.
<p>

In the presence of fog, objects gradually
fade from view, as a function of their
distance from your eye.
<i>Uniform</i> fog (ie: fog with the same
density everywhere)
is quite easy to model and render.
The key observation is that
for any uniform fog there is some distance
<i>D</i> that light will travel
before half of the light has been scattered away
by fog particles.
The other half of the light continues along
unobstructed.
<p>
Now consider what happens when the light
which has made it through the fog travels further
by another equal distance <i>D</i>.
Half of the <i>remaining</i> light
will now be scattered away,
and half of the remaining light
will make it through the second distance.
In other words, the light that makes it through
a distance <i>2D</i> unobstructed is <i>(1/2)<sup>2</sup></i>.
And in general, the amount of light that 
makes it through a distance <i>kD</i> is <i>(1/2)<sup>k</sup></i>.
<p>

To calculate uniform fog which
scatters half of its light every multiple of <i>D</i>,
you need to measure
the distance <i>d</i> traveled by the ray (ie: the distance from the ray origin
to the surface point that the ray hits).
The proportion of this light that
makes it through the fog unscattered will be <i>t=(1/2)<sup>d/D</sup></i>.
The effect of the fog can be shown by mixing
<i>t(surfaceColor) + (1-t)(fogColor)</i>,
where <i>surfaceColor</i> is the color
that you would have calculated had there been no fog.
Some uniform shade of light gray, such as
(0.8,0.8,0.8),
generally works well for the fog color.

<p>


</td><td valign=top width=20></td><td>
<canvas id=fog width=400 height=300 tabindex="1"></canvas>
<br>
<center><i>Move mouse up or down to change fog density
</td></tr></table><p>

<hr>
<table width=100% valign=top><tr><td>
<b><big>
Simple boolean shape combinations
</big></b><p>

Trying to implement the general
case of boolean shapes is very ambitious.
<p>
So for now let's just talk about the simplest case
(and a very useful one):
intersection of convex shapes.
<p>
A convex shape is one that is not <i>reentrant</i>.
That is, once a ray has entered the shape, the
ray can then exit the shape at most once,
and then never reenter that shape again.
For example, a cube and a cylinder are convex,
but a donut is not, since a single ray can enter
and then exit the same donut twice.
<p>
Unlike the general case, the rule when raytracing for
intersection of two convex shapes is very simple:
<ul>
<li>Let A and B be two shapes.
<br>
<li>Let <b>V</b>+t<b>W</b> be a ray.
<br>
<li>Let the entry and exit roots of A be t<sub>A<sub>0</sub></sub> and t<sub>A<sub>1</sub></sub>, respectively.
<br>
<li>Let the entry and exit roots of B be t<sub>B<sub>0</sub></sub> and t<sub>B<sub>1</sub></sub>, respectively.
</ul>

The intersection A&cap;B is found as follows:

<ul>
<li>The ray will enter A&cap;B at
max(t<sub>A<sub>0</sub></sub>,t<sub>B<sub>0</sub></sub>)
<br>
<li>The ray will exit A&cap; B at
min(t<sub>A<sub>1</sub></sub>,t<sub>B<sub>1</sub></sub>)
</ul>

<i>Note:</i> if
max(t<sub>A<sub>0</sub></sub>,t<sub>B<sub>0</sub></sub>) >
min(t<sub>A<sub>1</sub></sub>,t<sub>B<sub>1</sub></sub>),
this means the ray does not intersect A&cap;B.

<p><i><b>Example</b></i><p>

To ray trace to a unit cylinder (a tube with front and back end-caps):
<ul>
<li>Start with the infinite unit tube: &nbsp; x<sup>2</sup>+y<sup>2</sup>-1 &le; 0
<li> Then intersect with
half space: &nbsp; x - 1 &le; 0
<li>
Then intersect with
half space: &nbsp; -x - 1 &le; 0
</ul>

</td><td valign=top width=20></td><td>
<canvas id=booleans width=400 height=400 tabindex="1"></canvas>
</td></tr></table><p>

<script>
   var m = new M4();

   ray_cylinder.setup = function() {
      this.rotation = 0;
   }

   var diskN = [], diskP = [];
   var xy = makeOval(-1,-1,2,2, 80);
   for (var n = 0 ; n < xy.length ; n++) {
      var s = 0.08 * sin(24 * PI * n / (xy.length-1));
      diskN.push([xy[n][0],xy[n][1],-1.5 + s]);
      diskP.push([xy[n][0],xy[n][1], 1.5 + s]);
   }

   ray_cylinder.animate = function() {
      var w = width();
      var h = height();

      this.rotation = 1 - this.mouseX / (w/2);

      var a = [-1.5, 0.6,1.2];
      var d = [ 1.4,-0.6,-0.8];
      var b = vecLerp(.19, a, d);
      var c = vecLerp(.84, a, d);

      m.push();
         standardView(.5, .5, this.rotation, 0.2, .8);

         lineWidth(2);
         color('blue');
         mArrow(c, d);

         color('black');
         lineWidth(0.5);
         mCurve(diskP);
         lineWidth(0.2);
         mCurve(diskN);
         lineWidth(0.2);
         for (var n = 1 ; n < diskN.length ; n++)
            mLine(diskN[n], diskP[n]);

         color('blue');
         lineWidth(2);
         mLine(a, b);
         lineWidth(1);

         color('#ff8080');
         mLine(b, c);

         color('#8080ff');
         mArrow(c, d);

         color('#909090');
         mArrow([0,0,0],[1.5,0,0]);
         mArrow([0,0,0],[0,1.5,0]);
         mArrow([0,0,0],[0,0,1.5]);
         mText("X", [1.7-.05,-.05,0]);
         mText("Y", [0-.05,1.7-.05,0]);
         mText("Z", [0-.05,0-.05,1.7]);

         var mb = m.transform(b);
         fillOval(mb[0]-2,mb[1]-2,4,4);

         var mc = m.transform(c);
         fillOval(mc[0]-2,mc[1]-2,4,4);
      m.pop();
   }

   function drawSun(x, y, r, rgb) {
      if (typeof rgb == 'undefined')
         rgb = '#ffffe0';
      lineWidth(0.6);
      color('black');
      for (var n = 0 ; n < 12 ; n++) {
         var c = 1.5 * r * cos(n * PI / 12);
         var s = 1.5 * r * sin(n * PI / 12);
         line(x-c, y-s, x+c, y+s);
      }
      color(rgb);
      fillOval(x-r,y-r,2*r,2*r);
      color('black');
      drawOval(x-r,y-r,2*r,2*r);
   }

   local_lights.animate = function() {
      var w = width(), h = height();
      var x = this.mouseX, y = this.mouseY;
      var xMax = w*0.55;
      x = min(x, xMax);

      drawSun(x, h/2, w*lerp(y/h, .025, .06));

      var p = 2.05 - y / h;
      var pStr = ("" + p).substring(0, 3);
      textHeight(w/20);
      text("dropoff power = " + pStr, w/20*0.8, 2*w/20);

      lineWidth(2);
      for (var n = 0 ; n <= 40 ; n++) {
         var y = n * h / 40;

         var dx = (w - x) / (w-xMax);
         var dy = (y - h/2) / (w-xMax);
         var t = pow(dx * dx + dy * dy, -p);

         line(w, y, w - 0.8 * (w-xMax) * t, y);
      }

      lineWidth(4);
      color('#a0a0a0');
      line(w-2, 0, w-2, h);
   }

   var rgbs = [[255,0,0], [255,255,0], [0,128,255]];

   fog.animate = function() {
      var w = width(), h = height();

      var D = 5.05 * (h - this.mouseY) / h;

      var fr = 200, fg = 200, fb = 200;

      color('black');
      drawRect(0,0,w,h);
      color(fr, fg, fb);
      fillRect(0,0,w,h);

      for (var n = 8 ; n >= 0 ; n--) {
         var x = -1 + 2 * n / 8;
         var y = 0;
         var z = 1 + n;

	 var t = pow(0.5, z / D);

	 var xx = w*0.88 + w*0.6 * x/z;
	 var yy = h*0.50 - w*0.5 * y/z;
	 var zz = w / z;

	 var c = rgbs[n % rgbs.length];

         color(floor(lerp(t,fr,0)),
	       floor(lerp(t,fg,0)),
	       floor(lerp(t,fb,0)), 255);
	 drawRect(xx - zz*0.20, yy - zz*0.25, zz*0.40, zz*0.50);
         color(floor(lerp(t,fr,c[0])),
	       floor(lerp(t,fg,c[1])),
	       floor(lerp(t,fb,c[2])), 255);
	 fillRect(xx - zz*0.20, yy - zz*0.25, zz*0.40, zz*0.50);
         color(floor(lerp(t,fr,0)),
	       floor(lerp(t,fg,0)),
	       floor(lerp(t,fb,0)), 255);
	 textHeight(zz*0.08);
	 text("At"      , xx, yy, 1.8, 2.5);
	 text("distance", xx, yy, 0.5, 0.5);
	 textHeight(zz*0.12);
	 text(z         , xx, yy,-1.3,-0.8);
      }

      textHeight(w/20);
      color('black');
      text(("D = " + D).substring(0, 7), w/2, 0, 0.5, -0.7);
   }

   function raySegment(vx, vy, wx, wy, p0, p1) {
      var a = p0[1] - p1[1];
      var b = p1[0] - p0[0];
      var c = -(a * p0[0] + b * p0[1]);

      var t = -(a * vx + b * vy + c) / (a * wx + b * wy);
      var px = vx + t * wx;
      var py = vy + t * wy;

      var u = (py - p0[1]) / (p1[1] - p0[1]);
      if (u >= 0.0 && u <= 1.0)
         return [px, py];
      else
         return null;
   }

   function rayCurve(vx, vy, wx, wy, curve) {
      var roots = [];
      for (var i = 0 ; i < curve.length-1 ; i++) {
         var p = raySegment(vx, vy, wx, wy, curve[i], curve[i+1]);
         if (p)
	    roots.push(p);
      }
      return roots;
   }

   var arc0, arc1, arc2, arc3, tau = 2 * PI;
   var region = new Array();

   var shadowRegion;

   shadow.animate = function() {
      var w = width(), h = height();
      if (typeof shadowRegion == 'undefined') {
         shadowRegion = makeOval(.34*w-w/6, h/2-w/6, w/6, w/6, 40);
      }

      color('#f0f0ff');
      fillPolygon(shadowRegion);

      color('blue');
      lineWidth(1);
      drawPolygon(shadowRegion);

      let S = [ w/8, h/12 ];
      drawSun(S[0], S[1], h/32);

      lineWidth(4);
      color('#d0d0d0');
      line(0, h-10, w, h-10);
      color('#808080');
      line(w/4, h-10, 3*w/4, h-10);
      lineWidth(1.5);
      let V = [this.mouseX, h-10];
      let W = [ S[0] - V[0], S[1] - V[1] ];
      let p = rayCurve(V[0], V[1], W[0], W[1], shadowRegion);
      color(p.length > 0 ? '#000000' : '#808080');
      if (p.length > 0) {
         let i = p[0][1] > p[1][1] ? 0 : 1;
         line(V[0], V[1], p[i][0], p[i][1]);
      }
      else
         arrow(V[0], V[1], V[0] + .93 * W[0], V[1] + .93 * W[1]);
   }

   booleans.animate = function() {
      var w = width(), h = height();
      if (typeof arc0 == 'undefined') {
         var d = w/8;
         arc0 = makeOval(w/4-d, h/2-w/4, w/2, w/2, 40, tau*1/6, tau*5/6);
         arc0 = makeOval(w/4-d, h/2-w/4, w/2, w/2, 40, tau*1/6, tau*5/6);
         arc1 = makeOval(w/4-d, h/2-w/4, w/2, w/2, 20, tau*5/6, tau*7/6);
         arc2 = makeOval(w/4+d, h/2-w/4, w/2, w/2, 40, tau*1/3, tau*2/3);
         arc3 = makeOval(w/4+d, h/2-w/4, w/2, w/2, 20, tau*2/3, tau*4/3);

         for (var i = 0 ; i < arc1.length ; i++)
            region.push(arc1[i]);
         for (var i = 0 ; i < arc2.length ; i++)
            region.push(arc2[i]);
      }

      color('black');
      lineWidth(0.5);
      drawPolygon(arc0, 0,0,0, false);
      lineWidth(0.5);
      drawPolygon(arc3, 0,0,0, false);

      color('#f0f0ff');
      fillPolygon(region);

      color('blue');
      lineWidth(1.0);
      drawPolygon(region);

      var x = this.mouseX, y = this.mouseY;
      if (x >= w*0.05 && y >= h*0.05 && x < w*0.95 && y < h*0.95) {
         color('red');
         var x0 = w/2-w*0.35;
         var y0 = h/2-h*0.35;
         var dx = x-x0, dy = y-y0, r = sqrt(dx*dx + dy*dy);
         dx /= r;
         dy /= r;
         x1 = x0 + w*0.17 * dx;
         y1 = y0 + w*0.17 * dy;

         lineWidth(2);
         fillOval(x0-w*0.01,y0-w*0.01,w*0.02,w*0.02);
         arrow(x0, y0, x1, y1);

         lineWidth(0.5);
         arrow(x0, y0, lerp(20,x0,x1), lerp(20,y0,y1));

         var p = rayCurve(x0, y0, dx, dy, region);
         if (p.length >= 2) {
            color('blue');
            fillOval(p[0][0]-w*0.01, p[0][1]-w*0.01, w*0.02, w*0.02);
            fillOval(p[1][0]-w*0.01, p[1][1]-w*0.01, w*0.02, w*0.02);
            lineWidth(3);
            line(p[0][0], p[0][1], p[1][0], p[1][1]);
         }
      }
   }

</script>


<HR><TABLE width=100% valign=top><TR><TD>

<b><big>
A note on matrix inversion
</big></b><p>

In order to solve the general second order
equation, you will need inverse matrices.
There is a well known algorithm for inverting
an n&#215;n matrix by Gaussian elimination,
but alas it is not a good fit for hardware accelarated shaders.
<p>
One way to deal with this is by building
the inverse matrix in stages.
Every time you do an operation that 
would transform the forward matrix,
such as translation, rotation or scale,
perform the equivalent operation to transform the
corresponding inverse matrix.
<p>
For example, suppose you want to first
translate by (tx,ty,tz),
then rotate by &theta; about the x axis,
then scale by (sx,sy,sz):

<blockquote>
<table cellpadding=5><tr>
<td align=center bgcolor=#f0f0f0>
<pre>
 1  0  0  tx 
 0  1  0  ty 
 0  0  1  tz 
 0  0  0  1  
</pre>
</td>
<td align=center width=30><big>&bull;</big></td>
<td align=center bgcolor=#f0f0f0>
<pre>
 1  0  0  0 
 0  c -s  0 
 0  s  c  0 
 0  0  0  1 
</pre>
</td>
<td align=center width=30><big>&bull;</big></td>
<td align=center bgcolor=#f0f0f0>
<pre>
 sx 0  0  0 
 0  sy 0  0 
 0  0  sz 0 
 0  0  0  1 
</pre>
</td>
</tr></table>
</blockquote>

In the second matrix above,
c = cos(&theta;)
and
s = sin(&theta;).
<p>
In shader code, this might look something like:

<blockquote>
<pre>
mat4 m = identityMatrix();
m = m * translationMatrix(tx,ty,tz);
m = m * xRotationMatrix(theta);
m = m * scaleMatrix(sx,sy,sz);
</pre>
</blockquote>

<p>
You can compute the inverse of the resulting
matrix by applying the inverse of each
successive step, each time
multiplying on the left
rather than multiplying on the right:

<blockquote>
<pre>
mat4 mInv = identityMatrix();
mInv = translationMatrix(-tx,-ty,-tz) * mInv;
mInv = xRotationMatrix(-theta) * mInv;
mInv = scaleMatrix(1./sx,1./sy,1./sz) * mInv;
</pre>
</blockquote>
<p>

The product <code>m*mInv</code>
is guaranteed to be the identity matrix,
so this method does indeed compute the inverse.
<p>

Using this approach, you can even, if you like, implement functions
<code>translate(x,y,z)</code>,
<code>rotateX(theta)</code>,
<code>rotateY(theta)</code>,
<code>rotateZ(theta)</code>
and
<code>scale(x,y,z)</code>
that each update both a forward and an inverse transformation.
<p>

Note also that when doing rotations,
the following three rotation primitives are convenient
building blocks:

<blockquote>
<table cellpadding=5>
<tr>
<td align=center><i>Rot about x:</i></td>
<td width=20>
<td align=center><i>Rot about y:</i></td>
<td width=20>
<td align=center><i>Rot about z:</i></td>
</tr>
<tr>
<td align=center bgcolor=#f0f0f0>
<pre>
1  0  0  0
0  c -s  0
0  s  c  0
0  0  0  1
</pre>
</td>
<td width=20>
<td align=center bgcolor=#f0f0f0>
<pre>
 c  0  s  0 
 0  1  0  0 
-s  0  c  0 
 0  0  0  1 
</pre>
</td>
<td width=20>
<td align=center bgcolor=#f0f0f0>
<pre>
c -s  0  0
s  c  0  0
0  0  1  0
0  0  0  1
</pre>
</td>
</tr>
</table>

<!!td><!!canvas id=matrix width=400 height=400 tabindex="1"><!!/canvas><!!</td>

</TD></TR></TABLE><P>

<HR><TABLE width=100% valign=top><TR><TD>

<b><big>
Procedural texture
</big></b><p>

Procedural textures provide a powerful and flexible
way to create naturalistic and/or interesting
variations in surface appearance.
Once nice thing about them is that they allow you
to use the (x,y,z) position of a surface point itself
to tell you where to place the texture on the surface.
This is particularly convenient for ray tracing.
<p>
You can create a great variety
of naturalistic surface textures by using the
band limited noise
function (see below), which has the nice
property that it contains variations only
around a specific scale.
This property allows you to combine
calls to noise at different scales to
create a great variety of texture effects.
<p>
For example, a procedural stripe pattern
that would look very artificial by itself:
<blockquote><i>
f(x,y,z) = sin(x)
</i></blockquote>
can be make to look more natural by varying
the position of the stripes through the use of noise:
<blockquote><i>
f(<b>p</b>) = sin(p</sub>x</sub> + a * noise(f*<b>p</b>))
</i></blockquote>
In the above example, you can use
<i>f</i> to vary the frequency of noise pattern,
and
<i>a</i> to vary its amplitude.
<p>
You can create variations in the stripe pattern
at many different scales by adding sums of scaled noise:

<blockquote><i>
f(x,y,z) =
<big>&sum;<sub>i</sub> (</big>
sin(p</sub>x</sub> + a * noise(2<sup>i</sup>*f*<b>p</b>) / 2<sup>i</sup>)
<big>)</big>
</i></blockquote>

You can vary this
to create more realistic marble patterns by adding
"creases" to the noise at each scale.  You can
do this by using the absolute value
<i></i>|<i>noise(<b>p</b>)</i>|<i></i>
rather than
<i>noise(<b>p</b>)</i>:

<blockquote><i>
f(x,y,z) =
<big>&sum;<sub>i</sub> (</big>
sin(p</sub>x</sub> + a * </i>|<i>noise(2<sup>i</sup>*f*<b>p</b>)</i>|<i> / 2<sup>i</sup>)
<big>)</big>
</i></blockquote>

<p>

These are just a few examples.
I encourage you to try your hand at making
your own custom procedural textures.

<p>

<b><i>More on the noise function:</i></b><p>

<ul>
  <li> <a href=http://mrl.nyu.edu/~perlin/DragonPlanet2 target=1>A procedurally textured planet</a>
  <p>
  <li> <a href=http://mrl.nyu.edu/~perlin/DragonPlanet2/noise.js target=1>Shader implementation: noise.js, used for the planet</a>
  <p>
  <li> Note that the above source file also contains an implementation of turbulence
</ul>
<p>

<b><i>Procedural texture and Phong reflectance:</i></b><p>

You can use procedural textures to vary any
aspect of the Phong reflectance computation.
For example, you can use it to vary the
ambient or diffuse or specular color,
or the specular power (which creates variations in surface shininess).
<p>
You can also use it to vary the surface normal,
to create the appearance of bumpy surfaces.
To do this, you can first add a procedural texture
to each of the x,y and z components of your
surface normal vector,
and then renormalize the surface normal vector to unit length.
<p>

You can also use a similar technique for
mirror-like surfaces.
Here you would use the same technique as above to
vary the surface normal,
and then use the resulting normal vector to
compute your reflection vector.

<p>

<!!/td><!!td><!!canvas id=texture width=400 height=400 tabindex="1"><!!/canvas><!!/td>

</TD></TR></TABLE><P>

<HR><TABLE width=100% valign=top><TR><TD>

<b><big>
Refraction
</big></b><p>

<i>Snell's Law</i>
determines how much the light that
enters a transparent material (such as glass, water or clear plastic) will
change direction when it crosses the meterial's surface.
<p>
Every transparent material has an index
of refraction <i>n</i>,
which measures how slowly light travels
through that material.
The larger the value of <i>n</i>, the slower light travels through the material,
according to the rule:
<blockquote>
  n<sub>1</sub> sin &theta;<sub>1</sub> =
  n<sub>2</sub> sin &theta;<sub>2</sub>
</blockquote>

where &theta; is the deviation of a ray's direction from the surface normal.
The refractive index of air
is essentially 1.0, since light travels
pretty much as fast in air as it does in a vacuum.
The refractive index
of water is around 1.333,
of alcohol is around 1.36,
and of glass is around 1.5.
The substance with the highest known
refractive index is diamond, at 2.42.
<p>

As you can see in the diagram to the right,
light coming from a less dense medium
to a more dense medium
bends more toward the normal direction.
Light coming from a more dense medium
to a less dense medium
bends more away from the normal direction.
<p>

When going from a more dense medium
to a less dense medium at progressively
steeper angles,
at some point the <i>Brewster angle</i> is reached.
After this, the ray simply reflects back into
the more dense medium.
You can see this for yourself by
moving your mouse within the lower half of the
diagram to the right.

</td><td><canvas id=refraction width=400 height=400 tabindex="1"></canvas></td>

</TD></TR></TABLE><P>

<HR><TABLE width=100% valign=top><TR><TD>

<b><big>
Layered fog
</big></b><p>

<table width=100%><tr>
<td valign=top>

If fog is purely a function of y,
then it is non-uniform,
and therefore visually more interesting
than uniform fog,
yet also easy to integrate along a ray.
<p>

Here is an example of a layered fog density function, as a function of y (height):
<p>

<blockquote>
<table><tr>

<td valign=top>
d(y) =
</td>

<td valign=top>
if y &ge; -&pi; and y &le; &pi;
   <br>&nbsp; &nbsp; &nbsp;
   cos(y) + 1
<br>
else
   <br>&nbsp; &nbsp; &nbsp;
   0
</td>

</tr></table>
</blockquote>

The integral of this function with respect to y is:

<blockquote>
<table><tr>

<td valign=top>
dI(y) =
</td>

<td valign=top>
if y &lt; -&pi;
   <br>&nbsp; &nbsp; &nbsp;
   0
<br>
else if y &le; &pi;
   <br>&nbsp; &nbsp; &nbsp;
   &pi;
   +
   sin(y)
   +
   y
<br>
else
   <br>&nbsp; &nbsp; &nbsp;
   2&pi;
</td>

</tr></table>
</blockquote>

</td>
<td width=20></td>
<td>
<canvas id=layeredFog width=400 height=400 tabindex="1"></canvas>
</td>
</tr></table>

To compute the total density of a section of ray through this fog,
we need to integrate the density along the ray
(it doesn't matter which way -- we will be taking
the absolute value of the result).
Because the density varies only in y,
the integral along the slanted ray is the same
as the integral along a perfectly vertical ray,
if it were "stretched" in length.
<p>
The effect of this stretching is to multiply the
total density by 1/cos&theta;, where &theta; is
the angle by which the ray deviates from the vertical.

<p>
A special case occurs when the two ends
of the ray segment have the same value of y.
In this special case, we can treat the fog the same way we would treat uniform fog.
<p>

<b><i>Overview of algorithm:</i></b><p>

  <ul>
  <li> Given ray origin <b>V</b> and surface point <b>S</b>:
  <ul>
     <li> Compute density integral d along vertical interval S<sub>y</sub>...V<sub>y</sub>
     <li> Compute stretch due to horizontal component: s = |<b>V</b>-<b>S</b>| / |S<sub>y</sub>-V<sub>y</sub>|
     <li> Transparency from <b>V</b> to <b>S</b> is (0.5)<sup>sd</sup>
  </ul>
  </ul>
<p>

<!!/td><!!td><!!canvas id=refraction width=400 height=400 tabindex="1"><!!/canvas><!!/td>

</TD></TR></TABLE><P>

<HR><TABLE width=100% valign=top><TR><TD>

<b><big>
Cone tracing
</big></b><p>

The basic idea of cone tracing is to replace the ray
<i>(<b>V</b>,<b>W</b>)</i>
by the cone,
<i>(<b>V</b>,<b>W</b>,&alpha;)</i>,
where &alpha; is the radial angle at which the
cone spreads out as it moves away from its origin point
<i><b>V</b></i>.
<p>
For any distance <i>t</i> along the cone's medial ray,
we consider not just the single point
<i><b>V</b>+t<b>W</b></i>,
but rather the entire disk around that point of radius
<i>t tan(&alpha;)</i>.
<p>
Using a cone instead of a ray accounts for the fact that the extent of a
pixel is not a single point, but rather an area.
Cone tracing is also useful for modeling diffuse reflection and refraction, such as
reflection/refraction for non-smooth surfaces.
<p>

Tracing a cone to a sphere is slightly more complex than
tracing a ray to a sphere.  In addition to either hitting or missing
the sphere, a cone can graze the sphere, in which case
we need to approximate the fraction of the cone that intersects the sphere.
<p>

As John Amanatides described in his paper
<a href=https://www.semanticscholar.org/paper/Ray-tracing-with-cones-Amanatides/deb060036605110aab0690e047ddc668aa31d69b>Ray Tracing with Cones</a>,
we can quickly compute whether a cone intersects a sphere as follows:
<ul>
<li>
Given a cone with radial spread angle &alpha;, and a sphere
centered at
<i><b>C</b></i>
of radius
<i>R</i>,
Compute the point
<i><b>P</b></i>
where ray
<i><b>V</b>+t<b>W</b></i>
most closely approaches
<i><b>C</b></i>.
<p>
<li>
Consider the disk
<i>D<sub>p</sub>
= </i>{<i><b>P</b> , t tan(&alpha;)</i>}<i></i>
representing the cross section of the cone at distance
<i>t</i>.
This disk is centered at
<i><b>P</b></i>
and has radius
<i>t tan(&alpha;)</i>.
<p>
<li>
Consider also the disk
<i>D<sub>c</sub>
= </i>{<i><b>C</b>, R/cos(&alpha;)</i>}<i></i>
representing the visible extent of the sphere 
at distance
<i>t</i>
along the cone.
This disk is centered at
<i><b>C</b></i>
and has radius
<i>R/cos(&alpha;)</i>.
<p>
<li>
The cone will not intersect the sphere if the sum
of the two disk radii
<i>t tan(&alpha;)
+
R / cos(&alpha;)</i>
is less than the distance
<i></i>|<i><b>P</b>-<b>C</b></i>|<i></i>
from the cone to the sphere.
</ul>

<p>
If the cone does intersect the sphere,
then we obtain the fraction of the
cone that has intersected the sphere b
computing the intersection
of disk
<i>D<sub>p</sub></i>
and disk
<i>D<sub>c</sub></i>
and comparing this value
with the entire area of disk
<i>D<sub>p</sub></i>.

<p>

<!!/td><!!td><!!canvas id=cone-tracing width=400 height=400 tabindex="1"><!!/canvas><!!/td>

</TD></TR></TABLE><P>

<HR><TABLE width=100% valign=top><TR><TD>

<b><big>
Other kinds of implicit surfaces (advanced topic)
</big></b><p>

It is possible to create more sophisticated
types of implicit surface functions, which
allow more general shapes to be ray traced.
The basic idea is to create individual
functions that form simple shapes, such as spheres,
but which, when summed,
form surfaces that "melt" together into
more complex continuous shapes.
<p>

The first person
to publish a description of such a technique
was Jim Blinn in his 1982 paper
<a href=http://www.ks.uiuc.edu/Research/vmd/projects/ece498/surf/blinn82.pdf target=1>
A Generalization of Algebraic Surface Drawing</a>.
Unfortunately,
the technique described by Blinn could be
computationally expensive for ray tracing.
<p>

<table width=100%><tr>
<td valign=top>

In contrast, the <i>metaball</i> technique, developed
by a team of graduate students under the direction of
Koichi Omura at the University of Osaka
in the 1980s,
is much less computationally expensive to render by ray tracing.
Given a point <b>p</b>, consider procedure D(<b>p</b>):

<blockquote>
<pre>
r = |<b>p</b>|

if r < 1/3
   1 - 3*r<sup>2</sup>
else if r < 1
   1.5 * (1-r)<sup>2</sup>
else
   0
</pre>
</blockquote>

This procedure describes a smooth function
with both value and and gradient of zero
at a radius of 1, and which is zero everywhere that r &gt; 1.
<p>

We can create very complex
smooth shapes by summing together many metaballs:

<blockquote>
   <big>&sum;</big><sub>i</sub>
   <big>(</big>
   a<sub>i</sub>
   D(<b>M</b><sub>i</sub>&bull;<b>p</b>)
   <big>)</big>
   - &epsilon;
</blockquote>
<p>
where a<sub>i</sub> and <b>M</b><sub>i</sub>
are the amplitude and transformation matrix of each metaball,
respectively.
Subtracting a small &epsilon;
from the sum (eg: &epsilon; = 0.1)
guarantees a smooth transition between
shapes and a non-zero gradient at the surface.
<p>

</td>
<td width=20></td>
<td>
</td><td><canvas id=metaball width=300 height=400 tabindex="1"></canvas></td>
</td>
</tr></table>
<p>

Note that unless you want to
stretch the metaballs, you don't really need to do a full matrix transformation
for each metaball, since a metaball has spherical symmetry,
and therefore rotation is not needed.
Instead, you can just translate and scale, which is computationally less expensive.
<p>

To ray trace through such a sum of metaballs,
you can find the quadratic boundaries along the ray of each
transformed metaball.  Each metaball will
contain two such boundaries -- an inner one and an
outer one, reflecting the three cases of the metaball procedure.
Finding such a boundary is essentially just ray tracing to a sphere.
<p>
Within each of the regions formed between successive boundaries along a ray,
the ray encounters only a single smooth function,
which is a sum of smooth functions from individual metaballs.
Finding the surface (if there is one)
between two successive boundaries
requires finding the roots of this function along the ray.

<p>
To shade a metaball surface you need to find its surface normal.
To do this,
first compute the gradient of
the function at the ray/surface intersection.
The surface normal can then be found
by normalizing this gradient to unit length.

</TD></TR></TABLE>

<script>
   var m = new M4();

   function d(y) { return y >= -PI && y <= PI ? cos(y) + 1 : 0; }
   function dI(y) { return y < -PI ? 0 : y <= PI ? PI + sin(y) + y : 2 * PI; }

   layeredFog.setup = function() {
      var w = width(), h = height();

      this.y0 = h/2;
   }

   layeredFog.animate = function() {
      var w = width(), h = height();

      function y2f(y) { return (h-y - y0) / s; }
      function f2x(f) { return x0 + s * f; }

      var isMouseOverFigure = false;
      if ( this.mouseX >= 0.05 * w && this.mouseX <= 0.95 * w &&
           this.mouseY >= 0.05 * h && this.mouseY <= 0.95 * h) {
         this.y0 = h - this.mouseY;
	 isMouseOverFigure = true;
      }

      var dy = h / 60, s = h/20, x0 = w/4, y0 = this.y0;

      var dd = 5;
      for (var y = 0 ; y < h ; y += dd) {
         var c = floor(255 - 45 * d(y2f(y)));
         color(c, c, c, 255);
	 fillRect(0, y, w, dd);
      }

      lineWidth(1.0);

      color('black');
      text("d(y)", x0, 0, 1.2, -1.5);
      for (var y = 0 ; y < h ; y += dy)
         line(f2x(d(y2f(y))), y,
	      f2x(d(y2f(y+dy))), (y + dy));

      color('blue');
      text("dI(y)", x0 + s * dI(100), 0, 1.2, -1.5);
      for (var y = 0 ; y < h ; y += dy)
         line(f2x(dI(y2f(y))), y,
	      f2x(dI(y2f(y+dy))), (y + dy));

      color('red');
      var rx0 = w/8, ry0 = 3*h/4;
      var rx1 = w/2, ry1 = h/4;
      var rx = w*7/8;
      text("ray", rx0, ry0, 1.0, -0.5);
      arrow(rx0, ry0, w/2, ry1);

      var dI0 = dI(y2f(ry0));
      var dI1 = dI(y2f(ry1));

      var fx0 = f2x(dI0);
      var fx1 = f2x(dI1);

      color('red');
      lineWidth(0.25);
      if (rx0 < fx0) line(rx0, ry0, fx0, ry0);
      if (rx1 < fx1) line(rx1, ry1, fx1, ry1);

      color('blue');
      lineWidth(0.5);
      var lx = rx - w/7;

      line(lx, ry0, lx, h/2 + h/30);
      line(lx, ry1, lx, h/2 - h/30);

      line(fx0, ry0, lx, ry0);
      line(fx1, ry1, lx, ry1);

      color('blue');
      var str = ("" + (dI1 - dI0 + 0.001)).substring(0, 4);
      text("integral = " + str, rx, h/2, 1.0, 0.5);
   }

   refraction.setup = function() {
      var w = width(), h = height();

      this.x1 = -w/4;
      this.y1 = -w/4;

      this.n1 = 1.0;
      this.n2 = 1.5;
   }

   refraction.animate = function() {
      var w = width(), h = height();

      var isMouseOverFigure = false;
      if ( this.mouseX >= 0.05 * w && this.mouseX <= 0.95 * w &&
           this.mouseY >= 0.05 * h && this.mouseY <= 0.95 * h) {
         this.x1 = this.mouseX - w/2;
         this.y1 = this.mouseY - h/2;
	 isMouseOverFigure = true;
      }

      var x0 = w/2, y0 = h/2;
      var x1, y1, r1, x2, y2, r2;

      x1 = this.x1;
      y1 = this.y1;
      r1 = sqrt(x1*x1+y1*y1);

      color('#e8f0ff');
      fillRect(0,y0,w,h-y0);
      color('#0050ff');
      line(0,y0,w,y0);

      color('red');
      line(x0+x1,y0+y1, x0,y0);
      drawOval(x0+x1-w/100,y0+y1-w/100,w/50,w/50);
      color('#ffe0e0');
      fillOval(x0+x1-w/100,y0+y1-w/100,w/50,w/50);
      color('red');

      var n1 = y1 < 0 ? this.n1 : this.n2;
      var n2 = y1 < 0 ? this.n2 : this.n1;

      var s1 = abs(x1) / r1;

      var s2 = n1 * s1 / n2;
      if (s2 < 1) {
         var t2 = tan(asin(s2));

         y2 = -y1;
         x2 = y2 * t2 * (x1 < 0 == y1 < 0 ? 1 : -1);
         r2 = sqrt(x2*x2+y2*y2);

         x2 *= r1/r2;
         y2 *= r1/r2;
      }
      else {
         x2 = -x1;
         y2 = y1;
         r2 = sqrt(x2*x2+y2*y2);
      }
      arrow(x0,y0, x0+x2,x0+y2);

      color('#a0a0a0');
      text("air (n=1.0)", w/60, h/2 - w/30, 0, 0.5);
      color('#8098ff');
      text("glass (n=1.5)", w/60, h/2 + w/30, 0, 0.5);

      if (isMouseOverFigure) {
         color('#a0a0a0');
         line(w/2,0,w/2,h);

	 var t = function(x,y,r,s) {
	    var a = atan2(y,x);
	    var tx = x;
	    var ty = y + (y<0?-r:r);
	    var tr = sqrt(tx*tx + ty*ty);
	    tx *= w/10/tr;
	    ty *= w/10/tr;
	    text('\u03B8', x0 + tx, y0 + ty, 0.8, 0.5);
	    text(s, x0 + tx, y0 + ty,       -0.2, 0.0);
	 }
	 t(x1, y1, r1, '1');
	 t(x2, y2, r2, '2');
      }
   }

   metaball.setup = function() {
      var w = width(), h = height();

      this.x0 = w/3;
   }

   function mb(r) {
      r = abs(r);
      return r < 1/3 ? 1 - 3*r*r : r < 1 ? 1.5*(1-r)*(1-r) : 0;
   }

   metaball.animate = function() {
      var w = width(), h = height();

      var epsilon = 0.1;

      var isMouseOverFigure = false;
      if ( this.mouseX >= 0.05 * w && this.mouseX <= 0.95 * w &&
           this.mouseY >= 0.05 * h && this.mouseY <= 0.95 * h) {
         this.x0 = this.mouseX;
	 isMouseOverFigure = true;
      }

      var s = w / 4, y0 = h*3/8, dx = w / 60;
      var x0 = this.x0, x1 = w/2;

      function x2f(x) { return x / s; }
      function f2y(f) { return y0 - s * f; }

      function ms(x) { return mb(x2f(x - x0)) + mb(x2f(x - x1)); }

      for (var x = 0 ; x < w ; x += dx) {
         var f00 = x2f(x - x0);
         var f10 = x2f(x - x1);
         var f01 = x2f(x - x0 + dx);
         var f11 = x2f(x - x1 + dx);
         var m00 = mb(f00);
         var m10 = mb(f10);
         var m01 = mb(f01);
         var m11 = mb(f11);

	 color('black');
         line(x   , f2y(m00 + m10),
              x+dx, f2y(m01 + m11));

         if (isMouseOverFigure) {
	    color('#a0a0a0');
	    line(x, f2y(m00), x+dx, f2y(m01));
	    line(x, f2y(m10), x+dx, f2y(m11));
	 }
      }

      if (isMouseOverFigure) {
         color('#008080');
	 line(0, f2y(0.1), w, f2y(0.1));
      }

      var y0 = 3*h/4, xx, yy, rr0;

      var r = 0.21*w;

      var xLo = min(x0-r, x1-r);
      var xHi = max(x0+r, x1+r);

      function xy2rr(x, y) {
         var xx = x2f(x);
         var yy = x2f(y);
         return xx*xx + yy*yy;
      }

      for (var x = xLo ; x < xHi ; x += dx)
      for (var y = y0-r ; y < y0+r ; y += dx) {

         var rr0 = xy2rr(x - x0, y - y0);
         var rr1 = xy2rr(x - x1, y - y0);

	 if (rr0 > 1.0 && rr1 > 1.0)
	    continue;

         var sum = mb(sqrt(rr0)) + mb(sqrt(rr1));

	 if (sum > 0) {

	    var d = sum < 1.5 * epsilon ? dx / 4 : dx;

	    for (var xx = x ; xx < x + dx ; xx += d)
	    for (var yy = y ; yy < y + dx ; yy += d) {

	       if (xx > x || yy > y) {
                  rr0 = xy2rr(xx - x0, yy - y0);
                  rr1 = xy2rr(xx - x1, yy - y0);
                  sum = mb(sqrt(rr0)) + mb(sqrt(rr1));
               }

               if (sum >= epsilon) {
	          var c = sum;
	          c = 1 - c/2;
	          c = c * c;
	          c = 1 - .8 * c;
	          c = min(255, floor(255 * c));
	          color(0,c,c,255);
	          fillRect(xx,yy,d,d);
		  if (d < dx)
	             drawRect(xx,yy,d,d);
               }
            }
         }
      }
   }

</script>

</td></tr></table>

<hr color=white size=10>
<center><table width=90%><tr><td>

<HR>
<b><big>Improved noise in JavaScript:</big></b>
<p>

I've ported my
<a href=http://mrl.nyu.edu/~perlin/paper445.pdf target=1>Improved Noise</a>
algorithm to JavaScript, as the file
<a href=js/inoise.js target=1>inoise.js</a>.
<p>
You can use it to model shapes in various ways.
For example, a bumpy spheroid might be implemented like this:

<pre>
    var sph = function(u,v) {
       var theta = 2 * PI * u,
           phi = PI * (v - .5),
           cosT = cos(theta) , cosP = cos(phi) ,
           sinT = sin(theta) , sinP = sin(phi) ;
       var x = cosT * cosP, y = sinT * cosP, z = sinP;
       var r = 1 + noise(2*x, 2*y, 2*z) / 12
                 + noise(4*x, 4*y, 4*z) / 24;
       return [ r * x, r * y, 1.3 * r * z ];
    }
</pre>
<p>

Feel free to use this function in your geometric modeling.
<p>

<HR>
<table>
<tr>
<td valign=top>
<b><big>Triangle strips:</big></b>
<p>

<i>Triangle strips</i>
allow you to keep the transfer of geometry data from your CPU
to your GPU down to rougly one vertex per triangle.
In the version of <code>gl.js</code>
I provided last week, <code>g.TRIANGLE_STRIP</code> is already enabled,
so all you need to do is add vertices to your <code>vertices</code> array
in the proper order.
<p>
A way to do this with a general M&#215;N mesh
it to scan through rows (0 &le; n &le; N) in the outer loop,
and by columns (0 &le; m &le; M) in the inner loop,
scanning from left to right for even rows,
then back from right to the left for odd rows.
At each step of the inner loop, append the two vertices [m,n] and [m,n+1] to the 
<code>vertices</code> array.

<p>
In order to avoid spurious triangles
between rows, you can
<font color=red>repeat the last vertex two more times in each row</font>.
This will create a degenerate triangle, which is harmless.
<p>
To the right is an example of such an ordering.

</td>

<td>
<canvas id=triangle_strip width=400 height=300 tabindex=1></canvas> 
</td>
</tr>
</table>
<p>

<HR>
<b><big>Bump mapping:</big></b>
<p>

For fine perturbations of a surface,
it can be very expensive to generate and render the large
number of triangles required for true surface normal perturbation.
Therefore for finely detailed bumps, we sometimes
just use <i>Bump Mapping</i>, a technique first described
by Jim Blinn about 40 years ago.
<p>

The basic idea is to modulate the surface normal,
within the fragment shader, to reflect the changes
in surface direction that would be produced by
an actual bumpy surface.
Since the human eye is more sensitive to
variations in shading than to variations in object
silhouette, this technique can produce
a fairly convincing approximation to
the appearance of surface bumpiness,
at a fraction of the computational cost
of building finely detailed geometric models.
<p>

To do bump mapping of a procedural texture T
that is defined over the (x,y,z) domain
(the noise function is an example of one such procedural texture),
we can think of the value of T(x,y,z)
as a variation in surface height.
In order to simulate the hills and valleys of
this bumpy surface,
we subtract the derivative of T from
the normal (because the normal will point
<i>toward</i> the valleys),
and then renormalize to restore the normal vector to unit length.
<p>
We can approximate the vector valued derivative
at surface point <i>(x,y,z)</i>
by finite differences (where <i>&epsilon;</i> below
is some very small positive number):

<blockquote><i>
   p<sub><small>0</small></sub> = T(x,y,z)
<p>
   p<sub>x</sub> = (T(x+&epsilon;, y, z) - p<sub><small>0</small></sub>) / &epsilon;
<br>
   p<sub>y</sub> = (T(x, y+&epsilon;, z) - p<sub><small>0</small></sub>) / &epsilon;
<br>
   p<sub>z</sub> = (T(x, y, z+&epsilon;) - p<sub><small>0</small></sub>) / &epsilon;
<p>
</i></blockquote>

<table><tr>
<td valign=top>

which we can then use to modify the surface normal:

<blockquote><i>
   <b>normal</b> &larr; normalize(
   <b>normal</b> - vec3(p<sub>x</sub>,p<sub>y</sub>,p<sub>z</sub>) )

</i></blockquote>

<p>


<b><i>Advanced topic:</i></b> Bump mapping from a texture image is
more tricky, since you need to know
the direction to move the surface normal
with respect to changes in the <i>u</i> and <i>v</i>
directions of the texture, respectively.
Note that in the implementation of function
<code>createParametric()</code>,
I already compute exactly those quantities for each vertex,
as
<code>ux,uy,uz</code> and
<code>vx,vy,vz</code>, respectively.
These two direction vectors, which are
both tangential to the surface,
are sometimes called the
<i>tangent</i> and <i>binormal</i> vectors.
<p>
In order to do bump
mapping from a texture image,
you will need to include the tangent and binormal vectors
as part of your vertex data for each vertex.
This will increase the data size in each element
of the <code>vertices</code> array
from 10 numbers to 16 numbers.
Only try this if you are very confident,
and you think you understand the interface to WebGL.
<p>
</td>
<td valign=top>
<canvas id=bump_map width=400 height=300 tabindex=1></canvas> 
</td>
</tr></table>

<hr>

<script>

   triangle_strip.animate = function() {
      var M = 4, N = 3;

      function x(m) { return width()  * (.1 + .8 * m / M); }
      function y(n) { return height() * (.1 + .8 * (1 - n / N)); }

      var i = 0, ni = floor((2 * (M+1) * N + N-1) * this.mouseX / width());

      if (ni >= 0) {
         var r = 2*M+3;
         var k = ni % r;
         color(ni > 0 && (k==0 || k==r-1) ? 'red' : 'black');
         text("add vertex " + ni, width()/10, 20);
      }

      function draw(rgb, x0, y0, x1, y1, isDot) {
         color(rgb);
	 line(x0, y0, x1, y1);
	 if (isDot)
	    fillOval(x1-4, y1-4, 8, 8);
      }

      for (var n = 0 ; n < N ; n++)
      for (var m = 0 ; m <= M ; m++) {
         var x0 = x(n%2==0 ? m   : M-m  );
	 var x1 = x(n%2==0 ? m+1 : M-m-1);
         var y0 = y(n), y1 = y(n+1);
         if (m < M) {
            color('#a0a0a0');
            drawRect(x0, y0, x1 - x0, y1 - y0);
         }
         if (m == 0 && n == 0 && ni == 0)
	    draw('black', x0, y0, x0, y0, true);
         if (i < ni && n > 0 && m == 0)
	    draw('red', x0, y0, x0, y0, i++ == ni-1);
         if (i < ni)
	    draw('black', x0, y0, x0, y1, i++ == ni-1);
         if (i < ni)
            if (m < M)
	       draw('black', x0, y1, x1, y0, i++ == ni-1);
            else
	       draw('red', x0, y1, x0, y1, i++ == ni-1);
      }
   }

   bump_map.animate = function() {
      function f(u,v) {
         var x = 2*u - 1, y = 0, z = 2*v - 1;
         var t = -0.3 * (x*x + z*z);
         return [x, t, z];
      }
      var n = 20;
      m.push();
         standardView(.5,.5,0,0,.9);
         m.rotateY(-0.7 + PI + PI * this.mouseX / width());
         m.rotateX(-0.2);
	 color('#b0b0b0');
	 lineWidth(1);
	 for (var u = 0 ; u <= 1.001 ; u += 1/n)
	 for (var v = 0 ; v <= 1.001 ; v += 1/n) {
	    if (u < 1) mLine(f(u,v),f(u+1/n,v));
	    if (v < 1) mLine(f(u,v),f(u,v+1/n));
         }
	 color('black');
	 lineWidth(3);
	 mText("0,0", f(-0.05, 1.05));
	 mText("1,0", f( 1.05, 1.05));
	 mText("1,1", f( 1.05,-0.05));
	 mText("0,1", f(-0.05,-0.05));

	 color('blue');
	 mArrow([0,0,0], [0,1,0]);
	 mText("normal", [0,1,0],.5,1.5);

	 color('red');
	 mArrow([0,0,0], [1,0,0]);
	 mText("tangent", [1,0,0],.5,2.5);

	 color('#00a000');
	 mArrow([0,0,0], [0,0,-1]);
	 mText("binormal", [0,0,-1],.5,2.5);
      m.pop();
   }

   var pts=[[-1,-1,-1],[1,-1,-1],[-1,1,-1],[1,1,-1],[-1,-1,1],[1,-1,1],[-1,1,1],[1,1,1]];
   var edges=[[0,1],[2,3],[4,5],[6,7],[0,2],[1,3],[4,6],[5,7],[0,4],[1,5],[2,6],[3,7]];
   var m = new M4();
/*
   testCube.animate = function() {
      m.push();
         standardView(.5,.5,0,0,.5);
         m.rotateY(time);
         for (var i = 0 ; i < edges.length ; i++)
            mLine(pts[edges[i][0]], pts[edges[i][1]]);
      m.pop();
   }
*/
</script>


</center>

<p><b><big>Forward kinematics</big></b><p>

Often we want to create hierarchical mechanisms.
Such hierarchically structured mechanisms
generally use <i>forward kinematics</i>,
in which transformations form a tree
structure that descends from a single root.
<p>

Here is a swinging arm, a simple example of forward kinematics.
<p>
<table><tr>
<td valign=top>
Given a matrix object
<code>m</code> that has
methods to implement
<code>translate</code>,
<code>rotate</code>
and
<code>scale</code>,
as well as the ability to maintain an internal stack
of matrix values via
<code>push()</code> and
<code>pop()</code> methods,
the swinging arm is implemented via the following code:

<pre>
   m.push();
      standardView(.5,.5,0,0,.5);
      m.translate(-.5,2,0);
	 m.push();
         m.rotateZ(sin(3*time));
         m.translate(0,-1,0);
	 m.push();
	    m.scale(.1,1,.1);
	    unitCube();
	 m.pop();
	 m.translate(0,-1,0);
	 m.rotateZ(.5 - .5 * cos(3*time));
	 m.translate(0,-1,0);
	 m.push();
	    m.scale(.1,1,.1);
	    unitCube();
	 m.pop();
      m.pop();
   m.pop();
</pre>
</td>
<td width=20></td>

<td valign=top>
<canvas id=swinging_arm width=400 height=300 tabindex=1></canvas>
</td>
</tr></table>
<p>
For clarity, I implemented the above example using
push and pop methods.
But if you want to create a system that allows
users to put together their own object hierarchies,
you are better off using explicit objects.
<p>
In such a scheme,
each object would have its own matrix transformation,
and would also maintain a list of child objects.
The transformation of a child object would
be relative to its parent,
thereby forming a tree of object nodes.

<p><hr><b><big>Inverse kinematics</big></b><p>

<table><tr>
<td valign=top>
Inverse kinematics is the opposite of forward kinematics.
In an inverse kinematic system, you start with the
location of an end effector (such as a hand
or a foot or a robot gripper),
and the system needs to figure out the corresponding chain of
intermediate matrices from the root of the object hierarchy.
<p>
There are two common approaches to inverse kinematics,
general N-link IK and
special purpose 2-link IK.
The N-link approach requires an iterative solver,
whereas the 2-link approach has a closed form solution,
with no need for iteration.
<p>
To talk about 2-link IK, consider the case of an leg,
where the locations of the hip and ankle
are known, and we need to find the location of the knee.
<p>
To make the math simpler, let's assume
a hip located at the origin [0,0,0],
an upper leg of length <i>A</i>
and a lower leg of length <i>B</i>.
If the ankle is located at some point <b>P</b>,
we want to find the knee location <b>Q</b>.
<p>

Knee location <b>Q</b> can
lie anywhere on the circle of intersection
between two spheres:
The sphere of radius <i>A</i> centered at hip location [0,0,0]
and the sphere of radius <i>B</i> centered at ankle location <b>P</b>.
<p>
To pick the best point on this circle, we need to specify an aiming direction
<b>D</b> that says which way is "forward"
(since knees generally point forward).
<p>

What we need is a function that computes
<b>Q</b>, given
<i>A</i>,
<i>B</i>,
<b>P</b> and
<b>D</b>.
<p>
Here is my solution to this,
given a two-link chain at the origin,
with limb lengths
<code>a</code> and
<code>b</code>, respectively,
reaching toward point
<code><b>C</b></code>,
with elbow aim hint vector
<code><b>D</b></code>:

<pre>
   <i>c</i> = C&bull;C
   x = ((a<sup>2</sup>-b<sup>2</sup>)/<i>c</i> + 1)/2
   <b>D</b> -= <b>C</b>(C&bull;D)/<i>c</i>
   y = &radic;<span style="text-decoration: overline">max(0, a<sup>2</sup> - x<sup>2</sup><i>c</i>)</span>
   <b>Q</b> = x<b>C</b> + y<b>D</b>/|D|
</pre>

My implementation of this in Java is
<a href=https://mrl.cs.nyu.edu/~perlin/ik/ik.java.html target=1><font color=red>here</font></a>.
Feel free to use and adapt my algorithm.
</td>
<td width=20></td>
<td>
<canvas id=ik1 width=400 height=400 tabindex=1></canvas>
</td>
</tr></table>
<p>

<p><hr><b><big>Boids</big></b><p>

There is an entire sub-field of computer animation
devoted to swarms and particle animation.
One historically important example of this
was Craig Reynold's
<a href=http://www.red3d.com/cwr/boids/ target=1>Boids</a>,
which he first published in 1987.
This technique for simulating herding and flocking behavior
showed convincingly that a few simple procedural rules can
create the impression of compelling group and social behavior.
In cinema, this technique was first used in the 1992 feature
film <i>Batman Returns</i>, and has since become a
staple of the movie and game special effects industry.

<script>
   var pts=[[-1,-1,-1],[1,-1,-1],[-1,1,-1],[1,1,-1],[-1,-1,1],[1,-1,1],[-1,1,1],[1,1,1]];
   var edges=[[0,1],[2,3],[4,5],[6,7],[0,2],[1,3],[4,6],[5,7],[0,4],[1,5],[2,6],[3,7]];
   var m = new M4();

   function unitCube() {
      for (var i = 0 ; i < edges.length ; i++)
         mLine(pts[edges[i][0]], pts[edges[i][1]]);
   }

   swinging_arm.animate = function() {
      m.push();
         standardView(.5,.5,0,0,.5);
         m.translate(.2,2,0);
	 m.push();
            m.rotateZ(sin(3*time));
            m.translate(0,-1,0);
	    m.push();
	       m.scale(.1,1,.1);
	       unitCube();
	    m.pop();
	    m.translate(0,-1,0);
	    m.rotateZ(.5 - .5 * cos(3*time));
	    m.translate(0,-1,0);
	    m.push();
	       m.scale(.1,1,.1);
	       unitCube();
	    m.pop();
         m.pop();
      m.pop();
   }

   ik1.setup = function() {
      this.mouseX = width()/2;
      this.mouseY = width()*4/5;
   }
   ik1.animate = function() {
      var w = width(), h = height(), r = w/40, a = w*.23, b = w*.20;
      var ax = w/2, ay = h/2, cx = this.mouseX, cy = this.mouseY;

      var B = [cy-ay,ax-cx,0];
      ik(a, b, [cx-ax,cy-ay,0], B);
      var bx = ax + B[0], by = ay + B[1];

      var isOverextended = B[0]*B[0] + B[1]*B[1] > 1.1 * a * a;
      color(isOverextended ? 'red' : 'black');
      lineWidth(4);
      line(ax, ay, bx, by);
      line(cx, cy, bx, by);
      fillOval(ax-r, ay-r, 2*r, 2*r);
      fillOval(bx-r, by-r, 2*r, 2*r);
      fillOval(cx-r, cy-r, 2*r, 2*r);
      lineWidth(1);
      var d = sqrt((cx-ax)*(cx-ax) + (cy-ay)*(cy-ay));
      var dx = bx + w/8 * (cy-ay) / d, dy = by + w/8 * (ax-cx) / d;
      arrow(bx, by, dx, dy);
      text("D",lerp(1.2,bx,dx),lerp(1.2,by,dy),.7,.5);
      if (isOverextended)
         text("over-extending", w/20, w/20);
      color('white');
      fillOval(ax-r/2, ay-r/2, r, r);
      text("Q",bx,by,.6,.6);
      text("P",cx,cy,.6,.5);
   }

</script>

<hr><b><big>Procedurally animating a mesh over time:</big></b><p>

You can create a
procedurally animated mesh, in which
you define a
<code>VertexFilter</code>.
Behind the scenes this object
loops through a mesh's vertices one by one,
handing each one to a method
<code>filterVertex(double[] v)</code>
that allows you to modify their x,y,z values in place.
<p>
If you implement something like this in JavaScript,
you will need to keep two copies of your mesh:
The original unmodified mesh,
and the one that gets copied from the original
and then vertex-filtered at every animation frame.
<p>
When you modify the mesh, you will end up needing to change
the vertex normals.
To recompute vertex normals for a mesh, you
can use the following algorithm:

<ol>
<li>
Compute the normal to the plane of all the mesh's faces.
You can do this for any polygonal face with vertices
v<sub>0</sub> ... v<sub>n-1</sub>
by summing the cross products of successive edges:
(v<sub>i+1<sub>mod n</sub></sub> - v<sub>i</sub>)
&#215;
(v<sub>i+2<sub>mod n</sub></sub> - v<sub>i+1<sub>mod n</sub></sub>)
<p>
<li>
For every vertex, sum the face normals
of all faces adjoining that vertex,
then normalize the result.
This will give you a good approximation
to the normal at that vertex.
</ol>
<p>
If you are feeling ambitious, you can also
try implementing this sort of filter in a vertex shader.
In that case, you will need to be a bit more
clever about modifying vertex normals.
For example (since you will have greater
compute power to work with),
you can do finite differences to compute the new surface normals.
<p>

<hr><table><tr>
<td valign=top>
<b><big>Making footsteps:</big></b><p>
Here is my trick for placing feet
during a procedural character walk.
<p>
The trick is to "freeze" time periodically
for each foot position.
<p>
As the character's body moves along a path over time,
each foot moves alongside the body as well,
but the position of the foot is periodically "frozen"
while the foot is pressed against the ground and
supporting the weight of the body.
<p>
This is done by modifying the time argument,
by adding a sawtooth function to the time value passed to that foot:
<pre>
      time<sub>L</sub> += saw(time)
      time<sub>R</sub> += saw(time+1)
</pre>
where:
<pre>
      function saw(t) = { t%=2; return t<1 ? t : 2-t; }
</pre>
</td>
<td width=20></td>
<td valign=top>
<canvas id=timefreeze width=350 height=350 tabindex=1></canvas>
</td>
</tr></table>

<hr><b><big>Layered keyframe animation:</big></b><p>

Layered animation
allows you to create layered transparency
for parts of movement, in a way analogous
to how PhotoShop lets you do layered
transparency for just some pixels of an image but not others.
<p>

<hr>
<table><tr>
<td valign=top><b><big>General n-link inverse kinematics:</big></b><p>

Here is a simple way to do N-Link inverse kinematics,
given a chain of N+1 points P[0]....P[N],
building on our two-link IK algorithm:

<blockquote>
   For each link in the chain i = 1 through N-1:
   <ul>
      <li>Move the end effector P[N] fractionally toward the goal.
      <p>
      <li>Compute a new position for P[i] by solving for
      (P[i-1],P[i],P[N]) as a two-link IK chain.
      <p>
      <li>Transform all points P[i+1] through P[N-1]
      to match the translation+rotation
      defined by the new locations of P[i] and P[N].
   </ul>
</blockquote>
We can vary the compliance at each joint
by adjusting the fractional amount that
we move toward the goal at each step of the loop.
</td>
<td width=20></td>
<td valign=top>
<canvas id=nlink width=400 height=400 tabindex=1></canvas>
</td>
</tr></table>

<script>
   timefreeze.animate = function() {
      var w = width(), h = height();
      color('#c0c0c0');
      arrow(w*.1,h*.95, w*.1, h*.15);
      arrow(w*.1,h*.95, w*.9, h*.95);
      color('blue');
      var N = 4, x0, y0, x1, y1;
      var x = this.mouseX, ly = -100, ry = -100;
      for (var i = 0 ; i < N ; i++) {
         x0 = w * (.10 + .8 * (i-.25)/ N);
         y0 = h * (.95 - .8 *  i     / N);
         line(x1,y1,x0,y0);

         if (x >= x1 && x < x0)
	    ly = y0 + (y1 - y0) * (x - x0) / (x1 - x0);

         x1 = w * (.10 + .8 * (i+.25)/ N);
         y1 = h * (.95 - .8 *  i     / N);
         line(max(w*.1,x0),y0,x1,y1);

         if (x >= x0 && x < x1)
	    ly = y0 + (y1 - y0) * (x - x0) / (x1 - x0);
      }
      x1 = w * .10;
      y1 = h * .95;
      color('red');
      for (var i = 0 ; i < N ; i++) {
         x0 = w * (.10 + .8 * (i+.25)/ N);
         y0 = h * (.95 - .8 * (i+ .5)/ N);
         line(x1,y1,x0,y0);

         if (x >= x1 && x < x0)
	    ry = y0 + (y1 - y0) * (x - x0) / (x1 - x0);

         x1 = w * (.10 + .8 * (i+.75)/ N);
         y1 = h * (.95 - .8 * (i+ .5)/ N);
	 if (i < N-1)
            line(x0,y0,x1,y1);

         if (x >= x0 && x < x1)
	    ry = y0 + (y1 - y0) * (x - x0) / (x1 - x0);
      }
      if (x >= w*.1 && x < w*.9) {
         color('black');
	 textHeight(11);
	 text("time", x, h*.2, 1.2, .55);
	 arrow(x, h*.2, x+w*.1, h*.2);
	 text("travel"   , x+w*.015, h*.08, 0, -.1);
	 text("direction", x+w*.015, h*.08, 0, -1.2);
	 arrow(x+w*.06, h*.08, x+w*.06, h*.01);
         line(x, 0, x, h);
	 color('blue');
	 fillOval(x-w*.007,ly-w*.007,2*w*.007,2*w*.007);
	 text("left", x-w*.05, ly, .5, 1);
	 text("foot", x-w*.05, ly, .5, -.1);
	 color('red');
	 fillOval(x-w*.007,ry-w*.007,2*w*.007,2*w*.007);
	 text("right", x+w*.05, ry, .5, 1);
	 text("foot" , x+w*.05, ry, .5, -.1);
      }
   }

   nlink.animate = function() {
      var w = width(), h = height();
      var N = 6, x = this.mouseX;
      var px = [], py = [];
      var tx = fx(N-1) + w*.3, ty = fy(N-1) - w*.05;
      var f = (N-2) * x / w;
      var n = floor(f);
      if (x < w*.1) n=N;
      if (x >= w*.9) { n = N-3; f = N-2; }

      function fx(i) { t=sCurve(i/(N+1)); return (.1 + .6*t + (i==0?.1:i==N-1?-.15:0)) * w; }
      function fy(i) { t=i/(N+1); return (.8 - 2.0*t + 2.4*t*t - (i==0?.1:0)) * h; }

      function ex(i,j) { return px[j] - px[i]; }
      function ey(i,j) { return py[j] - py[i]; }
      function len(i,j) { var x=ex(i,j), y=ey(i,j); return sqrt(x*x+y*y); }

      for (var i = 0 ; i < N ; i++) {
         px[i] = fx(i);
         py[i] = fy(i);
      }

      color('blue');
      if (n==N) {
         lineWidth(.35);
         arrow(lerp(.1,px[N-1],tx), lerp(.1,py[N-1],ty),
               lerp(.9,px[N-1],tx), lerp(.9,py[N-1],ty));
         lineWidth(1);
      }
      else {
         var dx = (tx - px[N-1]) / (N-2);
         var dy = (ty - py[N-1]) / (N-2);
         for (var i = 0 ; i < N-1 ; i++)
	    fillOval(px[N-1]+i*dx-w*.005, py[N-1]+i*dy-w*.005,w*.01,w*.01);
         for (var i = 0 ; i < n+1 ; i++) {
	    var t0 = atan2(ey(i+1,N-1), ex(i+1,N-1));
	    var D = [ex(i,i+1), ey(i,i+1), 0];
	    var a = len(i,i+1);
	    var b = len(i+1,N-1);
	    if (i == n) {
	       px[N-1] += dx * (f - n);
	       py[N-1] += dy * (f - n);
	    }
	    else {
	       px[N-1] += dx;
	       py[N-1] += dy;
            }
	    ik(a, b, [ex(i,N-1), ey(i,N-1), 0], D);
	    var px1 = px[i+1], py1 = py[i+1];
	    px[i+1] = px[i] + D[0];
	    py[i+1] = py[i] + D[1];
	    var dt = atan2(ey(i+1,N-1), ex(i+1,N-1)) - t0;
	    var c = cos(dt), s = sin(dt);
	    for (var j = i+2 ; j < N-1 ; j++) {
	       var x = px[j]-px1, y = py[j]-py1;
	       px[j] = px[i+1] + c * x - s * y;
	       py[j] = py[i+1] + s * x + c * y;
	    }
	 }
      }

      for (var i = 0 ; i < N ; i++) {
	 if (i < N-1) {
	    color(n==N || i<n || f==N-2 ? 'black' : i==n ? 'red' : '#c0c0c0');
	    line(px[i], py[i], px[i+1], py[i+1]);
         }
      }
      if (n!=N && f < N-2) {
         color('red');
         line(px[n+1], py[n+1], px[N-1], py[N-1]);
      }

      color('blue');
      fillOval(tx - w*.01, ty - w*.01, w*.02, w*.02);

      for (var i = 0 ; i < N ; i++) {
	 color(n==N || i < n+1 || i==N-1 || f==N-2 ? 'black' : i==n+1 ? 'red' : '#a0a0a0');
         fillOval(px[i] - w*.01, py[i] - w*.01, w*.02, w*.02);
      }

      if (x >= w*.1 && x < w*.9 && f != N-2) {
         color('red');
         text("P["+n+"] -- P["+(n+1)+"] -- P["+(N-1)+"]",w*.5,h*.1,.5,.5);
      }
   }
</script>


<script src=js/table.js></script>

<hr><b><big>Introduction to particle systems:</big></b><p>


<p><b><i>Examples of uses of particle systems:</i></b><p>

This week we just scratched the surface of particle systems.
Next week we will go into more detail about this rich topic.
Meanwhile, here's a high level introduction to the subject.
<p>
Particle systems are very flexible; they can be used
to simulate many natural phenomena, including
water, leaves, clouds/fog, snow, dust, and stars.
<p>
When they are "smeared out"
so that they are rendered as trails, rather than as discrete
particles, they 
can be used to render hair, fur, grass, and
similar natural objects.


<p><b><i>Basic mechanism:</i></b><p>

Generally speaking, particles in a particle
system begin by being emitted from the surface
of an "emitter" object.
When a particle begins its life, it has an initial
trajectory, which is usually normal to the
surface of the emitter object.
<p>

After that, the path of the particle can be
influenced by various things,
including gravity and other forces,
and collisions with object surfaces.
<p>

Particles usually have a lifetime,
after which they are removed from the system.
<p>

Also, a particle can itself be an emitter of
other particles, spawning one or more other
particles in the course of its lifetime.
In this way, particles can be made to cascade,
generating complex patterns such as flamelike shapes.
<p>

All of the qualities of a particle -- its
lifetime, its velocity and mass, how many particles it spawns,
can be a randomly chosen value within some range.
By controlling the ranges from which these various
properties are chosen, artists can control the
look and feel of a particle system.


<p><b><i>History:</i></b><p>

Particle systems were first developed by
Bill Reeves at Pixar in 1981.
Its first public use was for the
Genesis Effect in
<a href=http://www.youtube.com/watch?v=QXbWCrzWJo4 target=1>
Star Trek 2, the Wrath of Khan 1982</a>.
Since then, it has become a mainstay
of computer graphic films and games.
<p>

<p><b><i>Rendering:</i></b><p>

One nice thing about particle systems is that
they are not that difficult to implement in vertex shaders.
In addition to their behavior, their appearance
can also be hardware accelarated.
One common technique is to render each particle
as a "billboard": a polygon
that is always
perpendicular to the camera.
This polygon is textured with a translucent
image of a fuzzy spot.  The effect is
to make the particle look like a small gaseous sphere,
but at fairly low computational cost.
<p>


<hr><b><big>Linear blend skinning:</big></b><p>

Here we discuss an approximation
to animating the soft skin of game characters
which is cheap and can be implemented
very easily in vertex shaders.
<p>

In an animated character,
the rigid bones of the character's articulating
skeleton are generally covered in some sort
of soft skin.
A fairly accurate way to model this skin would be to
think of each point on its surface
(approximated by the vertices of a polygon mesh),
as being influenced by the various rigid matrix
transformations of nearby bones in the skeleton.
<p>
To do this properly, one would compute a composite
transformation matrix that was influenced by all of
those individual bone matrices.
However, in practice this is a more expensive operation
than can be accommodated in the real-time rendering
budget of game engines.
<p>
So most games instead do a kind of cheat called <i>linear blend skinning</i>.
The basic idea is to compute the matrix transformation of each
vertex as a part of each of the various nearby bones.
This will result in a different position for each bone.
Then these positions are blended together into a weighted average
to find the final position for the vertex.
<p>
To make this work,
each vertex maintains a list of [bone,weight] pairs,
where all of the respective weights sum to 1.0.
<p>
This technique is very fast, and very easy to implement
efficiently in hardware accelarated vertex shaders,
but it has some practical deficiencies.
For example, twisting between the two ends of a limb
can cause the middle of the limb to appear to collapse.
To handle cases like this linear blend skinned skeletons
are rigged with extra bones to mitigate the effects
of such problems.
<p>

<hr><b><big>Marching Cubes:</big></b><p>

<b><i>Marching Squares (2D case):</i></b><p>

<TABLE>
<TR>

<td valign=top>
<hr color=white size=20>
Given a function f(x,y), where (x,y) are pixels in an image,
<i>marching squares</i> is a way to approximate the
curve along f(x,y) = 0.
<p>
For example, consider the function below
(which you can edit),
evaluated over the unit square:
<p>
<textArea rows=4 cols=80 id=f>
   function(x, y) {
      return 6 / (.1 + (2*x-0.8)*(2*x-0.8) + (2*y-1.0)*(2*y-1.0)) +
             1 / (.1 + (2*x-1.6)*(2*x-1.6) + (2*y-1.0)*(2*y-1.0)) - 16;
   }</textArea>
<br>
<button onclick="fChange();">RUN WITH CHANGE</button>
<p>
To the right you can see a very low resolution (10&#215;10)
rendering of this function.
Suppose we want to know the shape of the curve
where this function has its roots (that is, where <i>f(x,y) = 0</i>).
<p>
Ideally we'd like to know this without having
to evaluate the function at more samples.
</td>

<td width=20></td>

<td>
<canvas id=xyfunc1 width=300 height=300 tabindex=1></canvas>
</td>

</TR>
<TR>

<td valign=top>
<hr color=white size=20>
Marching squares provides a way to
get a sense of what a level-set curve of a
unction looks like, without taking more samples.
<p>
The key insight is that the curve can be approximated
just by looking at those pixels bounded by corner points
(i,j),(i+1,j),(i+1,j+1),(i,j+1)
for which the signs of f at the four corners are not all the same.
If the signs of f are different
at two adjoining corner points of a pixel's square,
that means the curve will cut the edge which
connects those two corners.
</td>

<td></td>

<td>
<canvas id=xyfunc2 width=300 height=300 tabindex=1></canvas>
</td>

</TR>
</TABLE>

<table><tr>
<td valign=top>
One thing we need to figure out is where
:his transition happens
along each such edge.
<p>

Given a value of A at corner a, and
a value of B at adjoining corner b,
we can compute the proportional distance t of the transition point along the edge [a,b]
by observing, by similar triangles:<p>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t/A = (1-t)/-B<br>
<font color=#8090a0>
&rarr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Bt = (1-t)A<br>
&rarr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-Bt = A - tA<br>
&rarr;<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(A-B)t = A<br>
&rarr;<br>
</font>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;t = A / (A-B)<br>
<p>
</td>
<td width=20></td>
<td>
<canvas id=interpolate width=400 height=400 tabindex=1></canvas>
</td>
</tr></table>

<table><tr>
<td valign=top>
Each corner can have two states: f&lt;0 or f&ge;0,
so in general, there are sixteen cases,
as shown in the diagram to the right.
Consider the second case along the top row of the diagram,
where f at the top left corner (i,j) of a pixel
is positive, but is negative at the other three corners of the pixel.
<p>
In this case, there is a transition point p along the top edge --
between (i,j) and (i+1,j), and another transition
point q along the left edge --
between (i,j) and (i,j+1).
Within this pixel, we can approximate the f(x,y)==0 curve
by the line segment [p,q].

<p>
So that for any pixel we need to do three things:
<ol>
<li>Figure out which edges, if any, of the pixel contain transition points
<li>Compute the locations of these points;
<li>Draw line segments between transition points, to approximate pieces of the curve.
</ol>
<p>

</td>
<td width=20></td>
<td>
<canvas id=marchingsquares width=400 height=400 tabindex=1></canvas>
</td>
</tr></table>

<p>
<table><tr>
<td valign=top>
<b><i>Marching Cubes (3D case):</i></b><p>

Marching cubes is the 3D equivalent of marching squares.
Rather than approximate a closed curve
where f(x,y)=0
via small straight edges inside square pixels,
as in marching squares,
the marching cubes algorithm approximates a closed surface
where f(x,y,z)=0
via small triangles inside cubic voxels.
The technical paper describing this algorithm, published by Lorensen and Cline in 1987,
has been cited more often than any other paper in the field of computer graphics.
<p>
Each voxel cube has eight corners, which can be numbered as follows:
<center>
<TABLE><TR>
<TD>
<table>
<tr><th>0</th><td width=20></td><td> <i>x=0 y=0 z=0</i> </td></tr>
<tr><th>1</th><td width=20></td><td> <i>x=1 y=0 z=0</i> </td></tr>
<tr><th>2</th><td width=20></td><td> <i>x=0 y=1 z=0</i> </td></tr>
<tr><th>3</th><td width=20></td><td> <i>x=1 y=1 z=0</i> </td></tr>
</table>
</TD><TD width=50></TD><TD>
<table>
<tr><th>4</th><td width=20></td><td> <i>x=0 y=0 z=1</i> </td></tr>
<tr><th>5</th><td width=20></td><td> <i>x=1 y=0 z=1</i> </td></tr>
<tr><th>6</th><td width=20></td><td> <i>x=0 y=1 z=1</i> </td></tr>
<tr><th>7</th><td width=20></td><td> <i>x=1 y=1 z=1</i> </td></tr>
</table>
</TD>
</TR></TABLE>
</center>
<p>

Because the value of f(x,y,z) at each of these eight corners can be
either
<font color=blue>positive</font>
or
<font color=red>negative</font>,
there are 2<sup>8</sup> or 256 cases to consider.
These are shown in the figure to the right.
<p>
I have included a <a href=js/table.js target=1>table</a>
to make things easier for you.
The table has 256 entries, one for each of the 256 cases.
Each entry contains between 0 and 4 triangles, which is
the number of triangles that will be produced by the
marching cube algorithm for a voxel of that type.

<p>
Each triangle is described by the three edges of the cube
that contain its respective vertices, and
each vertex is described by identifying one cube corner
as well as the orientation of the cube edge that contains that vertex.
<p>

For example, a particular vertex of a triangle in the table may be
described by the number sequence 0,1, indicating that this vertex lies on
edge [0,1] of the cube.  This is the edge that connects
the <i>x=0 y=0 z=0</i> corner of the cube and the
<i>x=1 y=0 z=0</i> corner of the cube.
</td>
<td width=20></td>
<td>
<canvas id=marchingcubes width=400 height=600 tabindex=1></canvas>
</td>
</tr></table>

<p>
<b><i>Marching Tetrahedra (simpler to implement, less efficient):</i></b><p>

<table><tr>
<td width=100% valign=top>
To avoid the big table look-up of Marching Cubes,
a technique I've used is to split up each voxel
into six tetrahedra.
Given the same corner numbering we used for Marching Cubes,
we can partition the voxel cube
by "turning on" the binary bits of the numbered corners in
different orders, giving the six tetrahedra:
<blockquote>
<div id=order></div>
</blockquote>
Since a tetrahedron has only four edges, there are only
two non-trivial boundary cases:
(1) the boundary is a single triangle, or
(2) the boundary is a four sided shape, which
can be split into two triangles.

<p>
This algorithm is less efficient than Marching Cubes,
because it generally produces more triangles for each boundary cube.  However it requires much less code, and therefore is easier to program, to debug, and to port to a vertex shader.

<p>
<td width=20>
<td valign=top>
<canvas id=tetrahedra width=300 height=300 tabindex=1></canvas>
</table>

<hr>

<script>
   var f = function(x, y) {
      return 6 / (.1 + (2*x-0.8)*(2*x-0.8) + (2*y-1.0)*(2*y-1.0)) +
             1 / (.1 + (2*x-1.6)*(2*x-1.6) + (2*y-1.0)*(2*y-1.0)) - 16;
   }

   var tf = document.getElementById('f');
   tf.onchange = 'console.log("hi mom")';
   tf.style.borderColor='white';
   tf.style.font="14px courier";

   function fChange() {
      console.log("hi mom");
      eval("f = " + tf.value);
   }

   xyfunc1.animate = function() {
      //isNoise = 0;
      var w = width(), h = height(), N = 10;
      for (var i = 0 ; i <= N ; i++)
      for (var j = 0 ; j <= N ; j++) {
         var u = .1 + .8 * i / N;
         var v = .1 + .8 * j / N;
	 var x = u * w;
	 var y = v * w;
	 var t = f(u, v);
	 color(t > 0 ? 'blue' : 'red');
	 fillRect(x - .01*w, y - .01*w, .02*w, .02*w);
      }

      var x = this.mouseX, y = this.mouseY;
      if (x >= .1*w && x < .9*w && y >= .1*h && y < .9*h) {
         var t = f(x/w, y/w);
	 color('black');
	 text(("" + t).substring(0,4), x, y, .5, .5);
      }
      isNoise = 1;
   }

   var mst = [[],[0,1,0,2],[0,1,1,3],[0,2,1,3],
              [0,2,2,3],[0,1,2,3],[0,1,0,2,1,3,2,3],[1,3,2,3],
              [1,3,2,3],[0,1,0,2,1,3,2,3],[0,1,2,3],[0,2,2,3],
              [0,2,1,3],[0,1,1,3],[0,1,0,2],[]];

   xyfunc2.animate = function() {
      //isNoise = 0;
      var w = width(), h = height(), N = 10, d = .8 / N;

      var x = this.mouseX, y = this.mouseY;
      if (x >= .1*w && x < .9*w && y >= .1*h && y < .9*h) {
	 var u = floor((x / w - .1) / d) * d + .1;
	 var v = floor((y / w - .1) / d) * d + .1;
	 var s = d/10*w;
	 for (var m = 0 ; m < 10 ; m++)
	 for (var n = 0 ; n < 10 ; n++) {
	    var U = u + m/10*d;
	    var V = v + n/10*d;
	    var t = f(U + d/20, V + d/20);
	    color(t >= 0 ? '#c0c0ff' : '#ffc0c0');
	    fillRect(U*w, V*w, s, s);
         }
      }

      lineWidth(.2);
      color('black');
      for (var i = 0 ; i <= N ; i++) {
         var u = .1 + .8 * i / N;
         line(u * w, .1 * h, u * w, .9 * h);
      }

      for (var j = 0 ; j <= N ; j++) {
         var v = .1 + .8 * j / N;
         line(.1 * w, v * h, .9 * w, v * h);
      }

      lineWidth(4);
      for (var i = 0 ; i < N ; i++)
      for (var j = 0 ; j < N ; j++) {
         var u = .1 + i * d;
         var v = .1 + j * d;
	 var F = [f(u,v), f(u+d,v), f(u,v+d), f(u+d,v+d)];
         var m = mst[ (F[0]>=0 ? 1 : 0) +
                      (F[1]>=0 ? 2 : 0) +
                      (F[2]>=0 ? 4 : 0) +
                      (F[3]>=0 ? 8 : 0) ];
         if (m.length > 0) {
	    var x = u * w;
	    var y = v * w;
	    var s = d * w;
            var p = [[x,y],[x+s,y],[x,y+s],[x+s,y+s]];
            for (var k = 0 ; k < m.length ; k += 4) {
	       var a0 = F[m[k  ]], b0 = F[m[k+1]];
	       var a1 = F[m[k+2]], b1 = F[m[k+3]];
	       var t0 = a0 / (a0 - b0);
	       var t1 = a1 / (a1 - b1);
	       line(lerp(t0, p[m[k  ]][0], p[m[k+1]][0]),
	            lerp(t0, p[m[k  ]][1], p[m[k+1]][1]),
	            lerp(t1, p[m[k+2]][0], p[m[k+3]][0]),
	            lerp(t1, p[m[k+2]][1], p[m[k+3]][1]));
	    }
	 }
      }
      isNoise = 1;
   }

   interpolate.animate = function() {
      var w = width(), h = height(), r = w / 16;
      var x1 = w/4, x2 = 3*w/4;

      var u = max(0, min(1, 2*this.mouseX / w - .5));

      var A = h/6 * u, B = -h/6 * (1-u);

      var t = A / (A-B);

      lineWidth(2);
      color('black');
      line(0,h/2, w,h/2);

      line(x1, h/2, x1, h/2-A);
      line(x1, h/2-A, x2, h/2-B);
      line(x2, h/2, x2, h/2-B);

      text("A", x1, h/2-A, .5, 1.4);
      text("B", x2, h/2-B, .5,-0.4);

      var x = lerp(t,x1,x2);

      color('#0080f0');
      text("t = A/(A-B)", x, h/4, .5,1.4);
      text("t", lerp(.5,x1,x), h/2, .5,-.4);
      text("1-t", lerp(.5,x,x2), h/2, .5,1.4);

      line(x,h/4, x,h/2);
   }

   marchingsquares.animate = function() {
      var w = width(), h = height(), r = w / 16, s = w * .025;

      function edge(a, b, c, d) {
	 line(x+a,y+b, x+c,y+d);

         if (row==R && col==C) {
            textHeight(width()*.03);
	    text("p", x+a,y+b, .5-.9*a/r, .7-.9*b/r);
	    text("q", x+c,y+d, .5-.9*c/r, .7-.9*d/r);
         }
      }

      function label(sgn, x, y) {
         color('black');
         color(sgn < 0 ? '#ffe0e0' : '#e0f0ff');
         fillOval(x - s*.9, y - s*.9, 2 * s*.9, 2 * s*.9);
         color('black');
         drawOval(x - s, y - s, 2 * s, 2 * s);
         textHeight(width()*.05);
	 text(sgn < 0 ? "-" : "+", x, y, .5, .6);
      }

      var C = floor(4 * this.mouseX / w);
      var R = floor(4 * this.mouseY / h);

      function m2x(i,j) { return i%2!=j%2 ? 0 : i%2==0 ? -r : r; }
      function m2y(i,j) { return m2x(floor(i/2), floor(j/2)); }

      for (var row = 0 ; row < 4 ; row++)
      for (var col = 0 ; col < 4 ; col++) {
         var x = (col + .5) * w / 4;
         var y = (row + .5) * h / 4;
	 var a = col % 2 == 0 ? -1 : 1;
	 var b = col % 4 <  2 ? -1 : 1;
	 var c = row % 2 == 0 ? -1 : 1;
	 var d = row % 4 <  2 ? -1 : 1;
	 color('black');
	 lineWidth(.5);
	 drawRect(x - r, y - r, 2 * r, 2 * r);
	 label(a, x - r, y - r);
	 label(b, x + r, y - r);
	 label(c, x - r, y + r);
	 label(d, x + r, y + r);
	 color(row==R && col==C ? 'black' : '#a0a0a0');
	 lineWidth(3);
	 var m = mst[4*row + col];
	 for (var k = 0 ; k < m.length ; k += 4)
	    edge(m2x(m[k  ],m[k+1]), m2y(m[k  ],m[k+1]),
	         m2x(m[k+2],m[k+3]), m2y(m[k+2],m[k+3]));
      }
   }

   var m = new M4();
   var theta = 0, state = 0, N = 0;

   marchingcubes.animate = function() {
      function sgn(a, b, d) {
         return b == d ? 0 : (a & 1<<d) > 0 ? 1 : -1;
      }
      var w = width(), h = height();
      var mx = this.mouseX, my = this.mouseY;
      if (mx > .01*w && mx < .99*w && my < .5*h)
         theta = .5 - mx/w;
      m.push();
         standardView(.5, .75, theta, .065, .95);
         color('black');
	 unitCube();
	 var t = table[N];
	 for (var k = 0 ; k < t.length ; k += 6) {
	    var a = t[k], b = t[k+1], c = t[k+2], d = t[k+3], e = t[k+4], f = t[k+5];
	    var A = [sgn(a, b, 0), sgn(a, b, 1), sgn(a, b, 2)];
	    var B = [sgn(c, d, 0), sgn(c, d, 1), sgn(c, d, 2)];
	    var C = [sgn(e, f, 0), sgn(e, f, 1), sgn(e, f, 2)];
            color('#ff808040');
	    mFillPolygon([A,B,C]);
            color('black');
	    mLine(A, B);
	    mLine(B, C);
	    mLine(C, A);
	 }

         var b = 0;
	 for (var z = -1 ; z < 1.1 ; z += 2)
	 for (var y = -1 ; y < 1.1 ; y += 2)
	 for (var x = -1 ; x < 1.1 ; x += 2) {
            color((N & 1<<b) > 0 ? 'blue' : 'red');
	    var P = m.transform([x,y,z]);
	    fillOval(P[0]-.01*w, P[1]-.01*w, .02*w, .02*w);
	    b++;
	 }
      m.pop();

      for (var row = 0 ; row < 16 ; row++)
      for (var col = 0 ; col < 16 ; col++) {
         var n = 16 * row + col;
	 var x = (col + .5) * w / 16;
	 var y = (row + .5) * h/2 / 16 + h / 2;
	 if (mx >= x - w/32 && mx < x + w/32 &&
	     my >= y - h/64 && my < y + h/64)
	   N = n;
         color(n == N ? 'black' : '#c0c0c0');
         textHeight(n == N ? 13 : 10);
	 text("" + n, x, y, .5, .5);
      }
      isNoise = 1;
   }

   tetrahedra.animate = function() {
      var w = width(), h = height(), theta = 0;
      var mx = this.mouseX, my = this.mouseY;
      let P = [
         [0,1,2],
	 [0,2,1],
	 [2,0,1],
	 [2,1,0],
	 [1,2,0],
	 [1,0,2],
      ];
      if (mx > .01*w && mx < .99*w)
         theta = .5 - mx/w;
      m.push();
         standardView(.5, .65, theta, .065, .95);
         color('black');
         lineWidth(.5);
	 unitCube();
         lineWidth(2);
         color('red');
	 let p = min(5, 8 * this.mouseY / h >> 0);
	 let i = P[p][0], j = P[p][1], k = P[p][2];
	 let A = [0,0,0], B = [0,0,0];
	 let draw = (a,b,c, d,e,f) => {
	    A[i]=a; A[j]=b, A[k]=c;
	    B[i]=d; B[j]=e, B[k]=f;
	    mLine(A, B);
	 }
	 draw(-1,-1,-1, 1,-1,-1);
	 draw( 1,-1,-1, 1, 1,-1);
	 draw( 1, 1,-1, 1, 1, 1);
	 draw(-1,-1,-1, 1, 1,-1);
	 draw(-1,-1,-1, 1, 1, 1);
	 draw( 1,-1,-1, 1, 1, 1);
let f = q => p==q ? '<font color=red><b>' : '<font color=black></b>';
order.innerHTML = `
`+f(0)+`[0,1,3,7] ,
`+f(1)+`[0,1,5,7] ,
`+f(2)+`[0,4,5,7] ,
`+f(3)+`[0,4,6,7] ,
`+f(4)+`[0,2,6,7] ,
`+f(5)+`[0,2,3,7]`;

      m.pop();
   }
</script>


</td></tr></table></center>


