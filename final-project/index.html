<body bgcolor=#6080ff><font face=helvetica>
<center>
<table>
</table>
<canvas id='canvas1' width=700 height=700></canvas>

<script>
let mInverse = m => {
	let dst = [], det = 0, cofactor = (c, r) => {
		let s = (i, j) => m[c+i & 3 | (r+j & 3) << 2];
		return (c+r & 1 ? -1 : 1) * ( (s(1,1) * (s(2,2) * s(3,3) - s(3,2) * s(2,3)))
											 - (s(2,1) * (s(1,2) * s(3,3) - s(3,2) * s(1,3)))
											 + (s(3,1) * (s(1,2) * s(2,3) - s(2,2) * s(1,3))) );
	}
	for (let n = 0 ; n < 16 ; n++) dst.push(cofactor(n >> 2, n & 3));
	for (let n = 0 ; n <  4 ; n++) det += m[n] * dst[n << 2]; 
	for (let n = 0 ; n < 16 ; n++) dst[n] /= det;
	return dst;
}

let mMult = (a, b) => {
	let dst = [];
	for (let n = 0 ; n < 16 ; n++)
		dst.push(a[n&3]*b[n&12] + a[n&3|4]*b[n&12|1] + a[n&3|8]*b[n&12|2] + a[n&3|12]*b[n&12|3]);
	return dst;
}

let matrix = [[1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]], c = t => Math.cos(t), s = t => Math.sin(t),
	 m = value => value ? matrix[matrix.length-1] = value : matrix[matrix.length-1];

mSave     =   ()   => matrix.push(m());
mRestore  =   ()   => matrix.pop();
mIdentity =   ()   => m([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]);
mMove    = (x,y,z) => m(mMult(m(), [1,0,0,0, 0,1,0,0, 0,0,1,0, x,y,z,1]));
mTurnX   =    t    => m(mMult(m(), [1,0,0,0, 0,c(t),s(t),0, 0,-s(t),c(t),0, 0,0,0,1]));
mTurnY   =    t    => m(mMult(m(), [c(t),0,-s(t),0, 0,1,0,0, s(t),0,c(t),0, 0,0,0,1]));
mTurnZ   =    t    => m(mMult(m(), [c(t),s(t),0,0, -s(t),c(t),0,0, 0,0,1,0, 0,0,0,1]));
mScale   = (x,y,z) => m(mMult(m(), [x,0,0,0, 0,y,0,0, 0,0,z,0, 0,0,0,1]));
mProject = (x,y,z) => m(mMult(m(), [1,0,0,x, 0,1,0,y, 0,0,1,z, 0,0,0,1]));

let start_gl = (canvas, vertexSize, vertexShader, fragmentShader) => {
	let gl = canvas.getContext("webgl");
	let program = gl.createProgram();
	gl.program = program;
	let addshader = (type, src) => {
		let shader = gl.createShader(type);
		gl.shaderSource(shader, src);
		gl.compileShader(shader);
		if (! gl.getShaderParameter(shader, gl.COMPILE_STATUS))
			throw "Cannot compile shader:\n\n" + gl.getShaderInfoLog(shader);
		gl.attachShader(program, shader);
	};
	addshader(gl.VERTEX_SHADER  , vertexShader  );
	addshader(gl.FRAGMENT_SHADER, fragmentShader);
	gl.linkProgram(program);
	if (! gl.getProgramParameter(program, gl.LINK_STATUS))
		throw "Could not link the shader program!";
	gl.useProgram(program);
	gl.bindBuffer(gl.ARRAY_BUFFER, gl.createBuffer());
	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LEQUAL);
	let vertexAttribute = (name, size, position) => {
		let attr = gl.getAttribLocation(program, name);
		gl.enableVertexAttribArray(attr);
		gl.vertexAttribPointer(attr, size, gl.FLOAT, false, vertexSize * 4, position * 4);
	}
	vertexAttribute('aPos', 3, 0);
	vertexAttribute('aNor', 3, 3);
	return gl;
}

let createTriangleStrip = (nu, nv, p) => {
	let vertices = [];
	for (let j = nv ; j > 0 ; j--) {
		for (let i = 0 ; i <= nu ; i++)
			vertices.push(p(i/nu,j/nv), p(i/nu,j/nv-1/nv));
		vertices.push(p(1,j/nv-1/nv), p(0,j/nv-1/nv));
	}
	let triangleStrip = new Float32Array(vertices.flat());
	triangleStrip.type = 'TRIANGLE_STRIP';
	return triangleStrip;
}

let strToTriangles = str => {
	let vertices = [];
	for (let n = 0 ; n < str.length ; n++)
		switch (str.charAt(n)) {
		case 'N': vertices.push(-1    ); break;
		case 'n': vertices.push(-0.577); break;
		case '0': vertices.push( 0    ); break;
		case 'p': vertices.push( 0.577); break;
		case 'P': vertices.push( 1    ); break;
		}
	let triangles = new Float32Array(vertices);
	triangles.type = 'TRIANGLES';
	return triangles;
}

let vertexSize = 6;
let vertexShader = `
	attribute vec3 aPos, aNor;
	uniform mat4 uMatrix, uInvMatrix;
	varying vec3 vPos, vNor;
	void main() {
		vec4 pos = uMatrix * vec4(aPos, 1.0);
		vec4 nor = vec4(aNor, 0.0) * uInvMatrix;
		vPos = pos.xyz;
		vNor = nor.xyz;
		gl_Position = pos * vec4(1.,1.,-.1,1.);
	}
`;
let fragmentShader = `
	precision mediump float;
	uniform vec3 uColor;
	varying vec3 vPos, vNor;
	void main(void) {
		vec3 color = vec3(.03,.04,.08) + uColor;
		gl_FragColor = vec4(sqrt(color), 1.);
	}
`;

setTimeout(() => {
	let gl = start_gl(canvas1, vertexSize, vertexShader, fragmentShader);

	let uColor     = gl.getUniformLocation(gl.program, "uColor");
	let uMatrix    = gl.getUniformLocation(gl.program, "uMatrix");
	let uInvMatrix = gl.getUniformLocation(gl.program, "uInvMatrix");

	let drawShape = (mesh, color) => {
		gl.uniform3fv      (uColor    , color);
		gl.uniformMatrix4fv(uMatrix   , false, m());
		gl.uniformMatrix4fv(uInvMatrix, false, mInverse(m()));
		gl.bufferData(gl.ARRAY_BUFFER, mesh, gl.STATIC_DRAW);
		gl.drawArrays(mesh.type == 'TRIANGLES' ? gl.TRIANGLES : gl.TRIANGLE_STRIP, 0, mesh.length / vertexSize);
	}

	let startTime = Date.now() / 1000;
	setInterval(() => {
		let time = Date.now() / 1000 - startTime;


	}, 30);
}, 100);
</script>

